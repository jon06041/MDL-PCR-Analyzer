<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug ML Pathogen Extraction</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; }
        .result { margin: 10px 0; padding: 10px; background: #f5f5f5; }
        .error { background: #ffe6e6; color: #d00; }
        .success { background: #e6ffe6; color: #060; }
        .warning { background: #fff3cd; color: #856404; }
        pre { background: #f0f0f0; padding: 10px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>Debug ML Pathogen Extraction Issue</h1>
    
    <div class="test-section">
        <h2>1. Simulate the Failing Well Data</h2>
        <div id="well-data-test"></div>
    </div>
    
    <div class="test-section">
        <h2>2. Test Pathogen Detection Methods</h2>
        <div id="pathogen-detection-test"></div>
    </div>
    
    <div class="test-section">
        <h2>3. Test Experiment Pattern Extraction</h2>
        <div id="pattern-test"></div>
    </div>
    
    <div class="test-section">
        <h2>4. Test Multichannel Pathogen Extraction</h2>
        <div id="multichannel-test"></div>
    </div>
    
    <div class="test-section">
        <h2>5. Check ML Training Data</h2>
        <div id="training-data-test"></div>
    </div>

    <!-- Load required scripts -->
    <script src="static/pathogen_library.js"></script>
    <script src="static/script.js"></script>
    <script src="static/ml_feedback_interface.js"></script>
    
    <script>
        function log(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = message;
            element.appendChild(div);
        }

        function testWellData() {
            log('well-data-test', '<h3>Testing Failing Well Data</h3>');
            
            // Simulate the exact well data from the log
            const failingWellData = {
                'well': 'P6_Texas Red',
                'target': '',
                'sample': '13980166-2-2576724',
                'classification': 'UNKNOWN'
            };
            
            log('well-data-test', `<pre>Failing well data:\n${JSON.stringify(failingWellData, null, 2)}</pre>`);
            
            // Show what fields are missing
            const missingFields = [];
            const expectedFields = ['pathogen', 'specific_pathogen', 'test_code', 'experiment_pattern'];
            
            expectedFields.forEach(field => {
                if (!failingWellData[field]) {
                    missingFields.push(field);
                }
            });
            
            log('well-data-test', `❌ Missing fields: ${missingFields.join(', ')}`, 'error');
            
            // Check if we can extract channel from well ID
            const wellId = failingWellData.well;
            const channelMatch = wellId.match(/(Cy5|FAM|HEX|Texas Red)$/);
            if (channelMatch) {
                log('well-data-test', `✅ Channel extracted from well ID: "${channelMatch[1]}"`, 'success');
            } else {
                log('well-data-test', `❌ Cannot extract channel from well ID: "${wellId}"`, 'error');
            }
        }

        function testPathogenDetection() {
            log('pathogen-detection-test', '<h3>Testing Pathogen Detection</h3>');
            
            // Test if we can get pathogen for Texas Red without test code
            const channel = 'Texas Red';
            
            // Check if we have any experiment pattern
            let experimentPattern = null;
            if (typeof getCurrentFullPattern === 'function') {
                experimentPattern = getCurrentFullPattern();
                log('pathogen-detection-test', `Current experiment pattern: "${experimentPattern || 'NONE'}"`);
            } else {
                log('pathogen-detection-test', '❌ getCurrentFullPattern function not available', 'error');
            }
            
            // Try to extract test code from pattern
            let testCode = null;
            if (experimentPattern && typeof extractTestCode === 'function') {
                testCode = extractTestCode(experimentPattern);
                log('pathogen-detection-test', `Test code from pattern: "${testCode || 'NONE'}"`);
            }
            
            // Try to get pathogen target
            if (testCode && typeof getPathogenTarget === 'function') {
                try {
                    const pathogen = getPathogenTarget(testCode, channel);
                    log('pathogen-detection-test', `✅ Pathogen for ${testCode}/${channel}: "${pathogen}"`, 'success');
                } catch (error) {
                    log('pathogen-detection-test', `❌ Error getting pathogen: ${error.message}`, 'error');
                }
            } else {
                log('pathogen-detection-test', '❌ Cannot get pathogen target (missing test code or function)', 'error');
            }
        }

        function testPatternExtraction() {
            log('pattern-test', '<h3>Testing Pattern Extraction from Sample</h3>');
            
            // Test various pattern extraction methods with the sample name
            const sampleName = '13980166-2-2576724';
            
            log('pattern-test', `Sample name: "${sampleName}"`);
            
            // This doesn't look like a standard CFX pattern, let's see what we can extract
            const patterns = [
                /^([A-Za-z]+)_/,  // Extract prefix before underscore
                /^([A-Za-z]+\d+)/,  // Extract alphanumeric prefix
                /(\d{8})/,  // Extract 8-digit number
                /^(.+?)-/  // Extract everything before first dash
            ];
            
            patterns.forEach((pattern, index) => {
                const match = sampleName.match(pattern);
                if (match) {
                    log('pattern-test', `Pattern ${index + 1}: "${match[1]}"`, 'warning');
                } else {
                    log('pattern-test', `Pattern ${index + 1}: No match`);
                }
            });
        }

        function testMultichannelExtraction() {
            log('multichannel-test', '<h3>Testing Multichannel Pathogen Extraction</h3>');
            
            // Simulate a 4-channel run with different pathogens per channel
            const multichannelWells = [
                { well: 'P6_Cy5', channel: 'Cy5', sample: '13980166-2-2576724' },
                { well: 'P6_FAM', channel: 'FAM', sample: '13980166-2-2576724' },
                { well: 'P6_HEX', channel: 'HEX', sample: '13980166-2-2576724' },
                { well: 'P6_Texas Red', channel: 'Texas Red', sample: '13980166-2-2576724' }
            ];
            
            log('multichannel-test', `Testing 4-channel run with sample: "${multichannelWells[0].sample}"`);
            
            // Try to extract test code from sample name
            const sampleName = multichannelWells[0].sample;
            
            // First, see if we can extract any pattern that might be a test code
            const possiblePatterns = [
                sampleName.match(/^(\d{8})/)?.[1],  // 8-digit prefix
                sampleName.match(/^(.+?)-/)?.[1],   // Everything before first dash
                sampleName.split('-')[0],           // Split on dash, take first part
                sampleName                          // Use full sample name
            ].filter(Boolean);
            
            log('multichannel-test', `Possible test codes from sample: ${possiblePatterns.join(', ')}`);
            
            // Test each channel to see if we can get pathogens
            multichannelWells.forEach(wellData => {
                log('multichannel-test', `<h4>Testing ${wellData.channel} Channel:</h4>`);
                
                let foundPathogen = false;
                
                // Try each possible test code
                possiblePatterns.forEach(testCode => {
                    if (typeof getPathogenTarget === 'function') {
                        try {
                            const pathogen = getPathogenTarget(testCode, wellData.channel);
                            if (pathogen && pathogen !== 'Unknown') {
                                log('multichannel-test', 
                                    `✅ ${wellData.channel}: "${testCode}" → "${pathogen}"`, 'success');
                                foundPathogen = true;
                            }
                        } catch (error) {
                            // Ignore errors, try next pattern
                        }
                    }
                });
                
                if (!foundPathogen) {
                    log('multichannel-test', 
                        `❌ ${wellData.channel}: No pathogen found for any test code pattern`, 'error');
                    
                    // Check what's available in the pathogen library for this channel
                    if (window.PATHOGEN_LIBRARY) {
                        const availablePathogens = [];
                        Object.keys(window.PATHOGEN_LIBRARY).forEach(pathogen => {
                            if (window.PATHOGEN_LIBRARY[pathogen][wellData.channel]) {
                                availablePathogens.push(pathogen);
                            }
                        });
                        
                        if (availablePathogens.length > 0) {
                            log('multichannel-test', 
                                `ℹ️ ${wellData.channel}: Available pathogens: ${availablePathogens.join(', ')}`, 'warning');
                        } else {
                            log('multichannel-test', 
                                `❌ ${wellData.channel}: No pathogens configured for this channel`, 'error');
                        }
                    }
                }
            });
            
            // Test the ML pathogen extraction logic directly
            log('multichannel-test', '<h4>Testing ML Interface Pathogen Extraction:</h4>');
            
            if (window.MLFeedbackInterface) {
                try {
                    const mlInterface = new window.MLFeedbackInterface();
                    const texasRedWell = {
                        well_id: 'P6_Texas Red',
                        channel: 'Texas Red',
                        sample: '13980166-2-2576724',
                        target: '',
                        pathogen: ''
                    };
                    
                    // Simulate the extraction process
                    const channelData = mlInterface.extractChannelSpecificPathogen(texasRedWell);
                    log('multichannel-test', 
                        `ML Interface extraction result: ${JSON.stringify(channelData, null, 2)}`, 
                        channelData.pathogen !== 'Unknown' ? 'success' : 'error');
                        
                } catch (error) {
                    log('multichannel-test', `❌ ML Interface test failed: ${error.message}`, 'error');
                }
            } else {
                log('multichannel-test', '❌ MLFeedbackInterface not available', 'error');
            }
        }

        async function testTrainingData() {
            log('training-data-test', '<h3>Testing ML Training Data Status</h3>');
            
            try {
                // Check if we can get ML stats
                const response = await fetch('/api/ml-stats');
                if (response.ok) {
                    const stats = await response.json();
                    log('training-data-test', `<pre>ML Statistics:\n${JSON.stringify(stats, null, 2)}</pre>`);
                    
                    if (stats.training_samples > 0) {
                        log('training-data-test', `✅ ${stats.training_samples} training samples available`, 'success');
                    } else {
                        log('training-data-test', '❌ No training samples available', 'error');
                    }
                    
                    if (stats.model_trained) {
                        log('training-data-test', '✅ General ML model is trained', 'success');
                    } else {
                        log('training-data-test', '❌ No general ML model trained', 'error');
                    }
                } else {
                    log('training-data-test', '❌ Cannot fetch ML statistics', 'error');
                }
            } catch (error) {
                log('training-data-test', `❌ Error fetching ML stats: ${error.message}`, 'error');
            }
        }

        // Run all tests when page loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                testWellData();
                testPathogenDetection();
                testPatternExtraction();
                testMultichannelExtraction();
                testTrainingData();
            }, 500);
        });
    </script>
</body>
</html>

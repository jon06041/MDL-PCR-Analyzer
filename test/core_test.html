<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Section Restoration Core Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
        }
        .test-controls {
            margin: 20px 0;
            text-align: center;
        }
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        .btn:hover {
            background: #0056b3;
        }
        .btn.success {
            background: #28a745;
        }
        .btn.danger {
            background: #dc3545;
        }
        .test-output {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            height: 400px;
            overflow-y: auto;
            margin: 10px 0;
            white-space: pre-wrap;
            font-size: 13px;
            line-height: 1.4;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.loading {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .test-card {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            background: #f8f9fa;
        }
        .test-card h4 {
            margin: 0 0 10px 0;
            color: #495057;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-indicator.pending {
            background: #6c757d;
        }
        .status-indicator.running {
            background: #ffc107;
            animation: pulse 1s infinite;
        }
        .status-indicator.passed {
            background: #28a745;
        }
        .status-indicator.failed {
            background: #dc3545;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .modal-body {
            border: 2px dashed #ccc;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            background: #f9f9f9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîß ML Section Restoration Core Test</h1>
            <p>Focused testing for modal element restoration without API dependencies</p>
        </div>

        <div class="test-controls">
            <button class="btn" onclick="runAllTests()">üöÄ Run All Tests</button>
            <button class="btn" onclick="runTest('multichannel', 'fresh')">üìä Multichannel Fresh</button>
            <button class="btn" onclick="runTest('multichannel', 'session')">üìà Multichannel Session</button>
            <button class="btn" onclick="runTest('single', 'fresh')">üìâ Single Fresh</button>
            <button class="btn" onclick="runTest('single', 'session')">üìã Single Session</button>
            <button class="btn" onclick="clearOutput()">üóëÔ∏è Clear</button>
        </div>
        
        <div id="status" class="status" style="display: none;"></div>

        <div class="test-grid" id="test-grid">
            <!-- Test cards will be populated here -->
        </div>

        <div class="test-output" id="output">
üîß ML Section Restoration Core Test
====================================

Ready to test core ML section restoration functionality...

This test focuses on the essential DOM manipulation and restoration logic:
‚úÖ createMLSectionInModal() functionality
‚úÖ refreshMLDisplayInModal() detection and restoration
‚úÖ Component verification after restoration
‚úÖ Modal content refresh simulation
‚úÖ Expert feedback display handling
‚úÖ Multichannel key format handling

Click "Run All Tests" to begin testing...
        </div>
        
        <!-- Simulated modal structure -->
        <div class="modal-body" id="mock-modal">
            <h4>üì± Mock Modal (for testing)</h4>
            <div class="modal-chart-container">Chart Container (Simulated)</div>
            <div id="modalDetails">Modal Details (Simulated)</div>
            <!-- ML section will be added/removed here during testing -->
        </div>
    </div>

    <script>
        const output = document.getElementById('output');
        const statusDiv = document.getElementById('status');
        let testResults = [];
        
        // Test status tracking
        const testStatuses = {
            'MULTICHANNEL_FRESH': 'pending',
            'MULTICHANNEL_SESSION': 'pending', 
            'SINGLE_FRESH': 'pending',
            'SINGLE_SESSION': 'pending'
        };

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            let prefix = 'üìù';
            
            switch(type) {
                case 'success':
                    prefix = '‚úÖ';
                    break;
                case 'error':
                    prefix = '‚ùå';
                    break;
                case 'warning':
                    prefix = '‚ö†Ô∏è';
                    break;
                case 'info':
                default:
                    prefix = 'üìù';
            }
            
            output.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }
        
        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
        }
        
        function hideStatus() {
            statusDiv.style.display = 'none';
        }
        
        function clearOutput() {
            output.textContent = '';
            hideStatus();
        }

        function createTestCards() {
            const testGrid = document.getElementById('test-grid');
            const tests = [
                { key: 'MULTICHANNEL_FRESH', title: 'Multichannel Fresh', description: 'Fresh multichannel data restoration' },
                { key: 'MULTICHANNEL_SESSION', title: 'Multichannel Session', description: 'Session multichannel with expert feedback' },
                { key: 'SINGLE_FRESH', title: 'Single Fresh', description: 'Fresh single channel data restoration' },
                { key: 'SINGLE_SESSION', title: 'Single Session', description: 'Session single channel with expert feedback' }
            ];

            testGrid.innerHTML = tests.map(test => `
                <div class="test-card" id="card-${test.key}">
                    <h4>
                        <span class="status-indicator pending" id="indicator-${test.key}"></span>
                        ${test.title}
                    </h4>
                    <p style="margin: 0; font-size: 13px; color: #6c757d;">${test.description}</p>
                </div>
            `).join('');
        }

        function updateTestStatus(testKey, status) {
            testStatuses[testKey] = status;
            const indicator = document.getElementById(`indicator-${testKey}`);
            if (indicator) {
                indicator.className = `status-indicator ${status}`;
            }
        }

        // Mock MLFeedbackInterface functionality
        class MockMLFeedbackInterface {
            constructor() {
                this.currentWellKey = null;
                this.currentWellData = null;
                log('üîß Mock ML Feedback Interface initialized', 'success');
            }

            setCurrentWell(wellKey, wellData) {
                this.currentWellKey = wellKey;
                this.currentWellData = wellData;
                log(`üìä Set current well: ${wellKey}`, 'info');
            }

            createMLSectionInModal() {
                try {
                    const modalBody = document.querySelector('.modal-body');
                    if (!modalBody) {
                        throw new Error('Modal body not found');
                    }

                    // Remove existing ML section if present
                    const existingSection = document.getElementById('ml-feedback-section');
                    if (existingSection) {
                        existingSection.remove();
                    }

                    // Create new ML section
                    const mlSection = document.createElement('div');
                    mlSection.id = 'ml-feedback-section';
                    mlSection.className = 'ml-feedback-section';
                    mlSection.innerHTML = `
                        <div class="ml-section-header">
                            <h4>ü§ñ Machine Learning Analysis</h4>
                        </div>
                        <div id="ml-prediction-display" class="ml-prediction-display">
                            <div class="prediction-result">
                                <span class="label">Classification:</span>
                                <span id="ml-prediction-class" class="value">${this.currentWellData?.classification || 'UNKNOWN'}</span>
                            </div>
                            <div class="prediction-confidence">
                                <span class="label">Confidence:</span>
                                <span id="ml-prediction-confidence" class="value">${this.currentWellData?.ml_classification?.confidence ? Math.round(this.currentWellData.ml_classification.confidence * 100) + '%' : 'N/A'}</span>
                            </div>
                            <div class="prediction-method">
                                <span class="label">Method:</span>
                                <span id="ml-prediction-method" class="value">${this.currentWellData?.ml_classification?.method || this.currentWellData?.curve_classification?.method || 'ML Classification'}</span>
                            </div>
                        </div>
                        <div class="ml-feedback-actions">
                            <button id="ml-feedback-btn" class="btn-feedback">üìù Submit Expert Feedback</button>
                        </div>
                        <div id="visual-curve-display" class="visual-curve-display">
                            <h5>üìä Visual Curve Analysis</h5>
                            <p>S-curve quality: ${this.currentWellData?.is_good_scurve ? 'Good' : 'Poor'}</p>
                            <p>Data points: ${this.currentWellData?.rfu_data?.length || 0}</p>
                            <p>Amplitude: ${this.currentWellData?.amplitude || 'N/A'}</p>
                        </div>
                        <form id="ml-feedback-form" class="ml-feedback-form" style="display: none;">
                            <div class="form-group">
                                <label>Expert Classification:</label>
                                <select id="expert-classification">
                                    <option value="POSITIVE">Positive</option>
                                    <option value="NEGATIVE">Negative</option>
                                    <option value="SUSPICIOUS">Suspicious</option>
                                </select>
                            </div>
                            <button type="submit" id="submit-feedback-btn" class="btn-submit">Submit Feedback</button>
                        </form>
                        <div id="ml-stats-display" class="ml-stats-display">
                            <h5>üìà Statistics</h5>
                            <p>R¬≤ Score: ${this.currentWellData?.r2_score || 'N/A'}</p>
                            <p>SNR: ${this.currentWellData?.snr || 'N/A'}</p>
                            <p>Steepness: ${this.currentWellData?.steepness || 'N/A'}</p>
                        </div>
                    `;
                    
                    modalBody.appendChild(mlSection);
                    
                    // Attach event listeners
                    this.attachEventListeners();
                    
                    log('‚úÖ ML section created successfully', 'success');
                    return true;
                    
                } catch (error) {
                    log(`‚ùå Failed to create ML section: ${error.message}`, 'error');
                    return false;
                }
            }

            refreshMLDisplayInModal() {
                try {
                    const existingMLSection = document.getElementById('ml-feedback-section');
                    if (!existingMLSection) {
                        log('üîç ML section missing, recreating...', 'warning');
                        return this.createMLSectionInModal();
                    } else {
                        log('‚úÖ ML section exists, no recreation needed', 'success');
                        return true;
                    }
                } catch (error) {
                    log(`‚ùå Failed to refresh ML display: ${error.message}`, 'error');
                    return false;
                }
            }

            attachEventListeners() {
                try {
                    const feedbackBtn = document.getElementById('ml-feedback-btn');
                    if (feedbackBtn) {
                        feedbackBtn.onclick = () => {
                            log('üìù Feedback button clicked', 'info');
                            const form = document.getElementById('ml-feedback-form');
                            if (form) {
                                form.style.display = form.style.display === 'none' ? 'block' : 'none';
                            }
                        };
                    }

                    const submitBtn = document.getElementById('submit-feedback-btn');
                    if (submitBtn) {
                        submitBtn.onclick = (e) => {
                            e.preventDefault();
                            log('‚úÖ Feedback submitted', 'success');
                            const form = document.getElementById('ml-feedback-form');
                            if (form) {
                                form.style.display = 'none';
                            }
                        };
                    }

                    log('‚úÖ Event listeners attached', 'success');
                } catch (error) {
                    log(`‚ùå Failed to attach event listeners: ${error.message}`, 'error');
                }
            }
        }

        // Test data generator
        function generateTestData() {
            return {
                multichannel: {
                    fresh: {
                        wellKey: 'A1_FAM',
                        wellData: {
                            well_id: 'A1',
                            channel: 'FAM',
                            fluorophore: 'FAM',
                            sample: 'Fresh_Multichannel_Sample',
                            classification: 'SUSPICIOUS',
                            amplitude: 450.2,
                            r2_score: 0.85,
                            snr: 5.2,
                            steepness: 0.3,
                            rfu_data: [100, 102, 105, 150, 200, 300, 450, 500, 520, 525],
                            cycles: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                            is_good_scurve: false
                        }
                    },
                    session: {
                        wellKey: 'A3_CY5',
                        wellData: {
                            well_id: 'A3',
                            channel: 'CY5',
                            fluorophore: 'CY5',
                            sample: 'Session_Multichannel_Sample',
                            classification: 'POSITIVE',
                            amplitude: 1200.5,
                            r2_score: 0.95,
                            snr: 15.8,
                            steepness: 0.8,
                            rfu_data: [80, 85, 90, 120, 200, 400, 800, 1200, 1250, 1260],
                            cycles: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                            is_good_scurve: true,
                            ml_classification: {
                                classification: 'POSITIVE',
                                confidence: 0.92,
                                method: 'Expert Review',
                                expert_review_method: 'ml_feedback_interface'
                            }
                        }
                    }
                },
                single: {
                    fresh: {
                        wellKey: 'B5',
                        wellData: {
                            well_id: 'B5',
                            channel: 'FAM',
                            sample: 'Fresh_Single_Sample',
                            classification: 'NEGATIVE',
                            amplitude: 85.3,
                            r2_score: 0.72,
                            snr: 2.1,
                            steepness: 0.1,
                            rfu_data: [75, 78, 80, 82, 85, 88, 85, 83, 84, 85],
                            cycles: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                            is_good_scurve: false
                        }
                    },
                    session: {
                        wellKey: 'C8',
                        wellData: {
                            well_id: 'C8',
                            channel: 'FAM',
                            sample: 'Session_Single_Sample',
                            classification: 'SUSPICIOUS',
                            amplitude: 380.7,
                            r2_score: 0.88,
                            snr: 6.5,
                            steepness: 0.4,
                            rfu_data: [90, 95, 100, 130, 180, 250, 350, 380, 385, 390],
                            cycles: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                            is_good_scurve: true,
                            curve_classification: {
                                classification: 'POSITIVE',
                                confidence: 0.88,
                                method: 'expert_feedback',
                                timestamp: new Date().toISOString()
                            }
                        }
                    }
                }
            };
        }

        // Component verification
        function verifyMLSectionComponents(context) {
            const mlSection = document.getElementById('ml-feedback-section');
            
            if (!mlSection) {
                throw new Error(`ML section not found (${context})`);
            }

            log(`‚úÖ ML section exists (${context})`, 'success');

            const requiredComponents = [
                'ml-prediction-display',
                'ml-feedback-btn',
                'visual-curve-display',
                'ml-prediction-method',
                'ml-prediction-class',
                'ml-prediction-confidence',
                'submit-feedback-btn',
                'ml-feedback-form',
                'ml-stats-display'
            ];

            const missingComponents = [];
            
            for (const componentId of requiredComponents) {
                const element = document.getElementById(componentId);
                if (!element) {
                    missingComponents.push(componentId);
                } else {
                    log(`  ‚úì ${componentId} found`, 'info');
                }
            }

            if (missingComponents.length > 0) {
                throw new Error(`Missing components: ${missingComponents.join(', ')}`);
            }

            log(`‚úÖ All ${requiredComponents.length} components verified (${context})`, 'success');
            return true;
        }

        // Mock global functions
        function setupMockEnvironment() {
            window.getCurrentFullPattern = () => 'TEST_PATTERN_2024';
            window.extractTestCode = (pattern) => pattern.split('_')[0];
            window.getPathogenTarget = (testCode, channel) => `${testCode}_${channel}_PATHOGEN`;
            window.currentSessionId = 'test_session_' + Date.now();
            window.currentModalWellKey = null;
            
            window.currentAnalysisResults = {
                individual_results: {}
            };

            window.updateModalContent = (wellKey) => {
                log(`üìã updateModalContent called for ${wellKey}`, 'info');
                const mlSection = document.getElementById('ml-feedback-section');
                if (mlSection) {
                    mlSection.remove();
                    log(`üóëÔ∏è ML section removed (simulating modal content refresh)`, 'info');
                }
            };

            log('‚úÖ Mock environment setup complete', 'success');
        }

        // Individual test execution
        async function runTest(channelType, dataType) {
            const testName = `${channelType.toUpperCase()}_${dataType.toUpperCase()}`;
            updateTestStatus(testName, 'running');
            
            log(`\nüöÄ Starting test: ${testName}`, 'info');
            log(`${'='.repeat(50)}`, 'info');

            try {
                const testData = generateTestData();
                const testConfig = testData[channelType][dataType];
                const { wellKey, wellData } = testConfig;

                log(`üìä Test configuration:`, 'info');
                log(`  Well Key: ${wellKey}`, 'info');
                log(`  Channel Type: ${channelType}`, 'info');
                log(`  Data Type: ${dataType}`, 'info');
                log(`  Sample: ${wellData.sample}`, 'info');
                log(`  Classification: ${wellData.classification}`, 'info');

                // Setup test environment
                setupMockEnvironment();
                
                // Add test data to global results
                window.currentAnalysisResults.individual_results[wellKey] = { ...wellData };

                // Initialize ML interface
                const mlInterface = new MockMLFeedbackInterface();
                await new Promise(resolve => setTimeout(resolve, 100));

                // Set current well
                mlInterface.setCurrentWell(wellKey, wellData);

                // Step 1: Create initial ML section
                const creationResult = mlInterface.createMLSectionInModal();
                if (!creationResult) {
                    throw new Error('Failed to create initial ML section');
                }
                log(`‚úÖ Initial ML section created`, 'success');

                // Step 2: Verify initial components
                verifyMLSectionComponents('Initial creation');

                // Step 3: Simulate modal content refresh (removes ML section)
                log(`üîÑ Simulating modal content refresh...`, 'info');
                window.updateModalContent(wellKey);
                await new Promise(resolve => setTimeout(resolve, 100));

                // Step 4: Verify ML section was removed
                let mlSection = document.getElementById('ml-feedback-section');
                if (mlSection) {
                    throw new Error('ML section should have been removed during modal refresh');
                }
                log(`‚úÖ ML section correctly removed during modal refresh`, 'success');

                // Step 5: Test restoration via refreshMLDisplayInModal
                log(`üîß Testing ML section restoration...`, 'info');
                const restorationResult = mlInterface.refreshMLDisplayInModal();
                if (!restorationResult) {
                    throw new Error('Failed to restore ML section');
                }
                await new Promise(resolve => setTimeout(resolve, 200));

                // Step 6: Verify ML section was recreated
                verifyMLSectionComponents('After restoration');

                // Step 7: Test button functionality
                log(`üß™ Testing button functionality...`, 'info');
                const feedbackBtn = document.getElementById('ml-feedback-btn');
                if (feedbackBtn) {
                    feedbackBtn.click();
                    log(`‚úÖ Feedback button click tested`, 'success');
                }

                log(`‚úÖ Test ${testName} PASSED`, 'success');
                testResults.push({ test: testName, status: 'PASSED' });
                updateTestStatus(testName, 'passed');

            } catch (error) {
                log(`‚ùå Test ${testName} FAILED: ${error.message}`, 'error');
                testResults.push({ test: testName, status: 'FAILED', error: error.message });
                updateTestStatus(testName, 'failed');
            } finally {
                // Cleanup
                const mlSection = document.getElementById('ml-feedback-section');
                if (mlSection) {
                    mlSection.remove();
                }
                window.currentAnalysisResults = { individual_results: {} };
                window.currentModalWellKey = null;
            }
        }

        // Run all tests
        async function runAllTests() {
            showStatus('Running all tests...', 'loading');
            clearOutput();
            testResults = [];
            
            log('üöÄ Starting comprehensive ML section restoration tests...', 'info');
            log('='*60, 'info');
            
            // Reset all test statuses
            Object.keys(testStatuses).forEach(key => updateTestStatus(key, 'pending'));
            
            const scenarios = [
                ['multichannel', 'fresh'],
                ['multichannel', 'session'],
                ['single', 'fresh'],
                ['single', 'session']
            ];

            for (const [channelType, dataType] of scenarios) {
                await runTest(channelType, dataType);
                await new Promise(resolve => setTimeout(resolve, 300));
            }

            // Print summary
            log('\nüìä TEST SUMMARY', 'info');
            log('='*60, 'info');
            
            const passed = testResults.filter(r => r.status === 'PASSED').length;
            const failed = testResults.filter(r => r.status === 'FAILED').length;
            
            log(`Total Tests: ${testResults.length}`, 'info');
            log(`Passed: ${passed}`, passed > 0 ? 'success' : 'info');
            log(`Failed: ${failed}`, failed > 0 ? 'error' : 'info');
            
            if (failed > 0) {
                log('\n‚ùå FAILED TESTS:', 'error');
                testResults.filter(r => r.status === 'FAILED').forEach(result => {
                    log(`  - ${result.test}: ${result.error}`, 'error');
                });
                showStatus(`${passed}/${testResults.length} tests passed`, 'error');
            } else {
                log('\n‚úÖ ALL TESTS PASSED!', 'success');
                showStatus(`All ${testResults.length} tests passed!`, 'success');
            }
            
            log('\nüéØ Test Coverage:', 'info');
            log('  ‚úÖ ML section creation and removal', 'success');
            log('  ‚úÖ ML section restoration after modal refresh', 'success');
            log('  ‚úÖ Component verification (buttons, displays, forms)', 'success');
            log('  ‚úÖ Multichannel key format handling', 'success');
            log('  ‚úÖ Expert feedback display handling', 'success');
            log('  ‚úÖ Fresh upload vs session data scenarios', 'success');
            log('='*60, 'info');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            createTestCards();
            log('üöÄ ML Section Restoration Core Test initialized', 'success');
            log('Click "Run All Tests" to begin comprehensive testing', 'info');
        });
    </script>
</body>
</html>

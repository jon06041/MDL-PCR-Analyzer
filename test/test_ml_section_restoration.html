<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Section Restoration Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-header {
            background: #007bff;
            color: white;
            padding: 10px;
            margin: -20px -20px 20px -20px;
            border-radius: 8px 8px 0 0;
        }
        .test-scenario {
            background: #e3f2fd;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #2196F3;
            border-radius: 4px;
        }
        .test-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .test-button:hover {
            background: #218838;
        }
        .test-button.secondary {
            background: #6c757d;
        }
        .test-button.secondary:hover {
            background: #5a6268;
        }
        .test-button.danger {
            background: #dc3545;
        }
        .test-button.danger:hover {
            background: #c82333;
        }
        .test-results {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        .test-status {
            padding: 5px 10px;
            border-radius: 4px;
            margin: 5px 0;
            font-weight: bold;
        }
        .test-status.pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-status.fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .test-status.pending {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .modal-simulation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 20px;
            min-width: 600px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 10000;
            display: none;
        }
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 9999;
            display: none;
        }
        .modal-header {
            background: #007bff;
            color: white;
            padding: 10px;
            margin: -20px -20px 20px -20px;
            border-radius: 6px 6px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }
        .modal-body {
            padding: 10px 0;
        }
        .modal-chart-container {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 20px;
            margin: 10px 0;
            border-radius: 4px;
            text-align: center;
            color: #6c757d;
        }
        #modalDetails {
            background: #e9ecef;
            border: 1px solid #ced4da;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .modal-parameter-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #dee2e6;
        }
        .classification-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 12px;
        }
        .positive { background: #d4edda; color: #155724; }
        .negative { background: #f8d7da; color: #721c24; }
        .suspicious { background: #fff3cd; color: #856404; }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h2>üß™ ML Section Restoration Test Suite</h2>
            <p>Testing ML section recreation across different scenarios: multichannel vs single channel, fresh uploads vs session data</p>
        </div>

        <div class="test-scenario">
            <h3>üî¨ Test Scenarios</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h4>Multichannel Tests</h4>
                    <button class="test-button" onclick="runTest('multichannel', 'fresh')">
                        üÜï Multichannel Fresh Upload
                    </button>
                    <button class="test-button" onclick="runTest('multichannel', 'session')">
                        üíæ Multichannel Session Data
                    </button>
                </div>
                <div>
                    <h4>Single Channel Tests</h4>
                    <button class="test-button" onclick="runTest('single', 'fresh')">
                        üÜï Single Channel Fresh Upload
                    </button>
                    <button class="test-button" onclick="runTest('single', 'session')">
                        üíæ Single Channel Session Data
                    </button>
                </div>
            </div>
        </div>

        <div class="test-scenario">
            <h3>üéØ Test Controls</h3>
            <button class="test-button secondary" onclick="runAllTests()">
                üöÄ Run All Tests
            </button>
            <button class="test-button secondary" onclick="clearResults()">
                üßπ Clear Results
            </button>
            <button class="test-button danger" onclick="resetEnvironment()">
                üîÑ Reset Test Environment
            </button>
        </div>

        <div class="test-scenario">
            <h3>üìä Test Results</h3>
            <div id="testResults" class="test-results">
Ready to run tests...

Test will verify:
‚úÖ ML section exists after modal content refresh
‚úÖ Feedback button is present and functional
‚úÖ Visual curve analysis is displayed
‚úÖ Method and result displays are working
‚úÖ Event listeners are properly attached
‚úÖ Expert feedback persistence works
‚úÖ Key format handling (A1_FAM vs A1_FAM_FAM)
            </div>
        </div>
    </div>

    <!-- Modal Simulation -->
    <div class="modal-backdrop" id="modalBackdrop"></div>
    <div class="modal-simulation" id="testModal">
        <div class="modal-header">
            <h4 id="modalTitle">Sample Details</h4>
            <button class="modal-close" onclick="closeModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div class="modal-chart-container">
                üìä Simulated Curve Chart
            </div>
            <div id="modalDetails">
                <div class="modal-parameter-item">
                    <span>Sample:</span>
                    <span id="modalSample">Test Sample</span>
                </div>
                <div class="modal-parameter-item">
                    <span>Well:</span>
                    <span id="modalWell">A1</span>
                </div>
                <div class="modal-parameter-item">
                    <span>Classification:</span>
                    <span id="modalClassification" class="classification-badge">SUSPICIOUS</span>
                </div>
                <div class="modal-parameter-item">
                    <span>Amplitude:</span>
                    <span id="modalAmplitude">450.2 RFU</span>
                </div>
            </div>
            <!-- ML section will be injected here -->
        </div>
    </div>

    <script src="static/ml_feedback_interface.js"></script>
    <script>
        // Test Data Simulation
        const testData = {
            multichannel: {
                fresh: {
                    wellKey: 'A1_FAM',
                    wellData: {
                        well_id: 'A1',
                        channel: 'FAM',
                        fluorophore: 'FAM',
                        sample: 'Fresh_Multichannel_Sample',
                        classification: 'SUSPICIOUS',
                        amplitude: 450.2,
                        r2_score: 0.85,
                        snr: 5.2,
                        steepness: 0.3,
                        rfu_data: [100, 102, 105, 150, 200, 300, 450, 500, 520, 525],
                        cycles: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                        is_good_scurve: false
                    }
                },
                session: {
                    wellKey: 'A3_CY5',
                    wellData: {
                        well_id: 'A3',
                        channel: 'CY5',
                        fluorophore: 'CY5',
                        sample: 'Session_Multichannel_Sample',
                        classification: 'POSITIVE',
                        amplitude: 1200.5,
                        r2_score: 0.95,
                        snr: 15.8,
                        steepness: 0.8,
                        rfu_data: [80, 85, 90, 120, 200, 400, 800, 1200, 1250, 1260],
                        cycles: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                        is_good_scurve: true,
                        ml_classification: {
                            classification: 'POSITIVE',
                            confidence: 0.92,
                            method: 'Expert Review',
                            expert_review_method: 'ml_feedback_interface'
                        }
                    }
                }
            },
            single: {
                fresh: {
                    wellKey: 'B5',
                    wellData: {
                        well_id: 'B5',
                        channel: 'FAM',
                        sample: 'Fresh_Single_Sample',
                        classification: 'NEGATIVE',
                        amplitude: 85.3,
                        r2_score: 0.72,
                        snr: 2.1,
                        steepness: 0.1,
                        rfu_data: [75, 78, 80, 82, 85, 88, 85, 83, 84, 85],
                        cycles: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                        is_good_scurve: false
                    }
                },
                session: {
                    wellKey: 'C8',
                    wellData: {
                        well_id: 'C8',
                        channel: 'FAM',
                        sample: 'Session_Single_Sample',
                        classification: 'SUSPICIOUS',
                        amplitude: 380.7,
                        r2_score: 0.88,
                        snr: 6.5,
                        steepness: 0.4,
                        rfu_data: [90, 95, 100, 130, 180, 250, 350, 380, 385, 390],
                        cycles: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                        is_good_scurve: true,
                        curve_classification: {
                            classification: 'POSITIVE',
                            confidence: 0.88,
                            method: 'expert_feedback',
                            timestamp: new Date().toISOString()
                        }
                    }
                }
            }
        };

        let mlFeedbackInterface = null;
        let testResults = [];

        // Initialize test environment
        function initializeTestEnvironment() {
            // Simulate global functions
            window.getCurrentFullPattern = () => 'TEST_PATTERN_2024';
            window.extractTestCode = (pattern) => pattern.split('_')[0];
            window.getPathogenTarget = (testCode, channel) => `${testCode}_${channel}_PATHOGEN`;
            window.currentSessionId = 'test_session_' + Date.now();
            window.currentModalWellKey = null;
            
            // Initialize analysis results
            window.currentAnalysisResults = {
                individual_results: {}
            };

            // Mock modal functions
            window.updateModalContent = function(wellKey) {
                log(`üìã updateModalContent called for ${wellKey}`);
                // Simulate modal content refresh that removes ML section
                const mlSection = document.getElementById('ml-feedback-section');
                if (mlSection) {
                    mlSection.remove();
                    log(`üóëÔ∏è ML section removed (simulating modal content refresh)`);
                }
                
                // Update modal details
                updateModalDisplay(wellKey);
            };

            window.buildModalNavigationList = function() {
                log(`üß≠ buildModalNavigationList called`);
                window.modalNavigationList = Object.keys(window.currentAnalysisResults.individual_results);
            };

            window.updateNavigationButtons = function() {
                log(`üîÑ updateNavigationButtons called`);
            };

            // Initialize ML feedback interface
            mlFeedbackInterface = new MLFeedbackInterface();
            log(`‚úÖ Test environment initialized`);
        }

        function updateModalDisplay(wellKey) {
            const wellData = window.currentAnalysisResults.individual_results[wellKey];
            if (!wellData) return;

            document.getElementById('modalTitle').textContent = `${wellKey} Details`;
            document.getElementById('modalSample').textContent = wellData.sample || 'Unknown';
            document.getElementById('modalWell').textContent = wellData.well_id || wellKey;
            document.getElementById('modalClassification').textContent = wellData.classification || 'UNKNOWN';
            document.getElementById('modalAmplitude').textContent = `${wellData.amplitude || 0} RFU`;
            
            // Set classification badge class
            const classificationBadge = document.getElementById('modalClassification');
            classificationBadge.className = `classification-badge ${getClassificationClass(wellData.classification)}`;
        }

        function getClassificationClass(classification) {
            const classMap = {
                'POSITIVE': 'positive',
                'NEGATIVE': 'negative',
                'SUSPICIOUS': 'suspicious'
            };
            return classMap[classification] || 'suspicious';
        }

        async function runTest(channelType, dataType) {
            const testName = `${channelType.toUpperCase()}_${dataType.toUpperCase()}`;
            log(`\nüöÄ Starting test: ${testName}`);
            log(`${'='.repeat(50)}`);

            try {
                // Get test data
                const testConfig = testData[channelType][dataType];
                const { wellKey, wellData } = testConfig;

                log(`üìä Test configuration:`);
                log(`  Well Key: ${wellKey}`);
                log(`  Channel Type: ${channelType}`);
                log(`  Data Type: ${dataType}`);
                log(`  Sample: ${wellData.sample}`);
                log(`  Classification: ${wellData.classification}`);

                // Step 1: Setup test data
                setupTestData(wellKey, wellData, dataType);

                // Step 2: Open modal to trigger initial ML section creation
                openModal(wellKey, wellData);

                // Step 3: Verify initial ML section exists
                await verifyMLSectionExists('Initial creation');

                // Step 4: Set current well in ML interface
                mlFeedbackInterface.setCurrentWell(wellKey, wellData);
                log(`‚úÖ Set current well: ${wellKey}`);

                // Step 5: Simulate modal content refresh (this removes ML section)
                log(`üîÑ Simulating modal content refresh...`);
                window.updateModalContent(wellKey);
                await sleep(100);

                // Step 6: Verify ML section was removed
                let mlSection = document.getElementById('ml-feedback-section');
                if (!mlSection) {
                    log(`‚úÖ ML section correctly removed during modal refresh`);
                } else {
                    log(`‚ö†Ô∏è ML section still exists after modal refresh`);
                }

                // Step 7: Call refreshMLDisplayInModal to test restoration
                log(`üîß Calling refreshMLDisplayInModal to test restoration...`);
                mlFeedbackInterface.refreshMLDisplayInModal();
                await sleep(200);

                // Step 8: Verify ML section was recreated
                await verifyMLSectionExists('After restoration');

                // Step 9: Test specific components
                await testMLComponents(wellData, dataType);

                // Step 10: Test expert feedback persistence
                if (dataType === 'session' && wellData.ml_classification) {
                    await testExpertFeedbackPersistence(wellKey, wellData);
                }

                log(`‚úÖ Test ${testName} PASSED`);
                updateTestStatus(testName, 'pass');

            } catch (error) {
                log(`‚ùå Test ${testName} FAILED: ${error.message}`);
                updateTestStatus(testName, 'fail', error.message);
            } finally {
                closeModal();
                await sleep(100);
            }
        }

        function setupTestData(wellKey, wellData, dataType) {
            // Add to global analysis results
            window.currentAnalysisResults.individual_results[wellKey] = { ...wellData };
            
            // For multichannel, also test key variations
            if (wellKey.includes('_')) {
                const duplicatedKey = wellKey.replace('_', '_') + '_' + wellKey.split('_')[1];
                window.currentAnalysisResults.individual_results[duplicatedKey] = { ...wellData };
                log(`üìù Added key variation: ${duplicatedKey}`);
            }

            // Simulate session storage for session data types
            if (dataType === 'session' && wellData.ml_classification) {
                const sessionKey = `expert_feedback_${wellKey}`;
                const expertData = {
                    classification: wellData.ml_classification.classification,
                    method: 'Expert Review',
                    confidence: 1.0,
                    expert_review_method: 'ml_feedback_interface',
                    timestamp: new Date().toISOString(),
                    wellKey: wellKey
                };
                sessionStorage.setItem(sessionKey, JSON.stringify(expertData));
                log(`üíæ Added session storage: ${sessionKey}`);
            }
        }

        function openModal(wellKey, wellData) {
            window.currentModalWellKey = wellKey;
            updateModalDisplay(wellKey);
            document.getElementById('modalBackdrop').style.display = 'block';
            document.getElementById('testModal').style.display = 'block';
            log(`üìÇ Modal opened for ${wellKey}`);
        }

        function closeModal() {
            window.currentModalWellKey = null;
            document.getElementById('modalBackdrop').style.display = 'none';
            document.getElementById('testModal').style.display = 'none';
            
            // Clean up ML section
            const mlSection = document.getElementById('ml-feedback-section');
            if (mlSection) {
                mlSection.remove();
            }
        }

        async function verifyMLSectionExists(context) {
            const mlSection = document.getElementById('ml-feedback-section');
            
            if (!mlSection) {
                throw new Error(`ML section not found (${context})`);
            }

            log(`‚úÖ ML section exists (${context})`);

            // Verify key components
            const components = [
                'ml-prediction-display',
                'ml-feedback-btn',
                'visual-curve-display',
                'ml-prediction-method',
                'ml-prediction-class'
            ];

            for (const componentId of components) {
                const element = document.getElementById(componentId);
                if (!element) {
                    throw new Error(`Component ${componentId} not found in ML section`);
                }
                log(`  ‚úì ${componentId} found`);
            }

            return true;
        }

        async function testMLComponents(wellData, dataType) {
            log(`üîç Testing ML components...`);

            // Test visual curve analysis
            const visualDisplay = document.getElementById('visual-curve-display');
            if (visualDisplay) {
                log(`  ‚úì Visual curve analysis component found`);
                
                // Check if it gets populated
                const shapeElement = document.getElementById('curve-shape-assessment');
                const patternElement = document.getElementById('curve-pattern-type');
                
                if (shapeElement && patternElement) {
                    log(`  ‚úì Visual analysis elements found`);
                } else {
                    log(`  ‚ö†Ô∏è Some visual analysis elements missing`);
                }
            }

            // Test feedback button
            const feedbackBtn = document.getElementById('ml-feedback-btn');
            if (feedbackBtn) {
                log(`  ‚úì Feedback button found`);
                
                // Test if it's clickable
                feedbackBtn.click();
                await sleep(100);
                
                const feedbackForm = document.getElementById('ml-feedback-form');
                if (feedbackForm && feedbackForm.style.display !== 'none') {
                    log(`  ‚úì Feedback form opens correctly`);
                } else {
                    log(`  ‚ö†Ô∏è Feedback form not visible after click`);
                }
            }

            // Test method and classification display
            const methodElement = document.getElementById('ml-prediction-method');
            const classElement = document.getElementById('ml-prediction-class');
            
            if (methodElement && classElement) {
                log(`  ‚úì Method and classification elements found`);
                
                if (dataType === 'session' && wellData.ml_classification) {
                    // Should show expert feedback
                    log(`  üìä Expected: Expert Review method for session data`);
                } else {
                    log(`  üìä Expected: Regular ML or analyze button for fresh data`);
                }
            }
        }

        async function testExpertFeedbackPersistence(wellKey, wellData) {
            log(`üéØ Testing expert feedback persistence...`);

            // Check if expert feedback is displayed
            const methodElement = document.getElementById('ml-prediction-method');
            const classElement = document.getElementById('ml-prediction-class');
            
            if (methodElement && classElement) {
                const methodText = methodElement.textContent;
                const classText = classElement.textContent;
                
                log(`  üìä Method: ${methodText}`);
                log(`  üìä Classification: ${classText}`);
                
                if (methodText.includes('Expert') || methodText.includes('Review')) {
                    log(`  ‚úÖ Expert feedback method detected`);
                } else {
                    log(`  ‚ö†Ô∏è Expert feedback method not showing`);
                }
                
                if (classText.includes(wellData.ml_classification.classification.replace('_', ' '))) {
                    log(`  ‚úÖ Expert classification displayed correctly`);
                } else {
                    log(`  ‚ö†Ô∏è Expert classification not showing correctly`);
                }
            }

            // Check session storage
            const sessionKey = `expert_feedback_${wellKey}`;
            const storedFeedback = sessionStorage.getItem(sessionKey);
            if (storedFeedback) {
                log(`  ‚úÖ Session storage contains expert feedback`);
                const parsed = JSON.parse(storedFeedback);
                log(`    - Classification: ${parsed.classification}`);
                log(`    - Method: ${parsed.method}`);
            } else {
                log(`  ‚ö†Ô∏è No expert feedback found in session storage`);
            }
        }

        async function runAllTests() {
            log(`\nüöÄ Running all test scenarios...`);
            log(`${'='.repeat(60)}`);
            
            const scenarios = [
                ['multichannel', 'fresh'],
                ['multichannel', 'session'],
                ['single', 'fresh'],
                ['single', 'session']
            ];

            for (const [channelType, dataType] of scenarios) {
                await runTest(channelType, dataType);
                await sleep(500); // Brief pause between tests
            }

            log(`\nüìä All tests completed!`);
            log(`${'='.repeat(60)}`);
        }

        function clearResults() {
            document.getElementById('testResults').textContent = 'Results cleared...\n\nReady to run tests.';
            testResults = [];
            
            // Clear test status indicators
            const statusElements = document.querySelectorAll('.test-status');
            statusElements.forEach(el => el.remove());
        }

        function resetEnvironment() {
            // Clear session storage
            const keys = Object.keys(sessionStorage);
            keys.forEach(key => {
                if (key.startsWith('expert_feedback_')) {
                    sessionStorage.removeItem(key);
                }
            });

            // Reset global state
            window.currentAnalysisResults = { individual_results: {} };
            window.currentSessionId = 'test_session_' + Date.now();
            
            // Close modal
            closeModal();
            
            // Clear results
            clearResults();
            
            log(`üîÑ Test environment reset complete`);
        }

        function updateTestStatus(testName, status, error = null) {
            // Remove existing status for this test
            const existingStatus = document.getElementById(`status-${testName}`);
            if (existingStatus) {
                existingStatus.remove();
            }

            // Create new status indicator
            const statusDiv = document.createElement('div');
            statusDiv.id = `status-${testName}`;
            statusDiv.className = `test-status ${status}`;
            
            let statusText = `${testName}: `;
            switch (status) {
                case 'pass':
                    statusText += '‚úÖ PASSED';
                    break;
                case 'fail':
                    statusText += `‚ùå FAILED${error ? ` - ${error}` : ''}`;
                    break;
                case 'pending':
                    statusText += '‚è≥ RUNNING';
                    break;
            }
            
            statusDiv.textContent = statusText;
            
            // Insert after test results
            const testResults = document.getElementById('testResults');
            testResults.parentNode.insertBefore(statusDiv, testResults.nextSibling);
        }

        function log(message) {
            const resultsElement = document.getElementById('testResults');
            const timestamp = new Date().toLocaleTimeString();
            resultsElement.textContent += `[${timestamp}] ${message}\n`;
            resultsElement.scrollTop = resultsElement.scrollHeight;
            console.log(message);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            log('üîß Initializing test environment...');
            initializeTestEnvironment();
            log('‚úÖ Test environment ready!');
            log('üìù Click any test button to start testing ML section restoration');
        });
    </script>
</body>
</html>

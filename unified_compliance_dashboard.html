<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Validation & Compliance Dashboard - MDL PCR Analyzer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .dashboard-container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .back-button {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 20px;
            border-radius: 50px;
            text-decoration: none;
            transition: all 0.3s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            color: white;
            text-decoration: none;
            transform: translateY(-50%) scale(1.05);
        }

        .header h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.3em;
            opacity: 0.9;
        }

        .compliance-score {
            position: absolute;
            top: 20px;
            right: 30px;
            background: rgba(255, 255, 255, 0.2);
            padding: 15px 25px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }

        .score-number {
            font-size: 2.2em;
            font-weight: bold;
        }

        .score-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .status-card {
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
            transition: transform 0.2s;
        }
        
        .status-card:hover {
            transform: translateY(-2px);
        }
        
        .status-active { border-left: 5px solid #28a745; }
        .status-partial { border-left: 5px solid #ffc107; }
        .status-planned { border-left: 5px solid #17a2b8; }
        .status-ready { border-left: 5px solid #6f42c1; }
        
        .evidence-badge {
            font-size: 0.8em;
            padding: 0.3rem 0.6rem;
            border-radius: 15px;
            margin: 0.2rem;
            display: inline-block;
        }
        
        .evidence-found { background: #d4edda; color: #155724; }
        .evidence-missing { background: #f8d7da; color: #721c24; }
        .evidence-partial { background: #fff3cd; color: #856404; }
        
        .regulation-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .requirement-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .requirement-item:hover {
            border-color: #007bff;
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.1);
        }
        
        .requirement-expanded {
            border-color: #007bff;
            background: #f8f9ff;
        }
        
        .implementation-feature {
            background: #e3f2fd;
            border-left: 3px solid #2196f3;
            padding: 0.5rem 1rem;
            margin: 0.5rem 0;
            border-radius: 0 4px 4px 0;
        }
        
        .evidence-detail {
            background: #f1f8e9;
            border: 1px solid #c3e6cb;
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        .metric-card {
            text-align: center;
            padding: 1.5rem;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .metric-number {
            font-size: 2.5rem;
            font-weight: bold;
            color: #007bff;
        }
        
        .export-section {
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        
        .roadmap-item {
            border-left: 4px solid #007bff;
            background: #f8f9ff;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 4px 4px 0;
        }
        
        .nav-pills .nav-link.active {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
        }
        
        .tab-content {
            margin-top: 2rem;
            padding: 0 30px 30px 30px;
        }

        .dashboard-content {
            background: white;
        }
        
        /* Workflow Steps */
        .workflow-steps {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            text-align: center;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 2rem;
            border-radius: 10px;
            border: 1px solid #dee2e6;
        }

        .workflow-step {
            flex: 1;
            padding: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .workflow-step:hover {
            transform: translateY(-2px);
        }

        .workflow-step i {
            color: #007bff;
        }

        /* Stat Cards */
        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            transition: transform 0.2s;
        }

        .stat-card:hover {
            transform: translateY(-2px);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            line-height: 1;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #007bff, #17a2b8);
        }

        /* Metrics for pathogen models */
        .metric {
            text-align: center;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 6px;
            margin-bottom: 0.5rem;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            line-height: 1;
        }

        .metric-label {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: 0.25rem;
        }

        /* Version timeline */
        .version-timeline {
            border-left: 2px solid #007bff;
            padding-left: 1rem;
        }

        .version-entry {
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #e9ecef;
        }

        .version-entry:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="header">
            <a href="/" class="back-button">
                <i class="fas fa-arrow-left"></i>
                Back to Main
            </a>
            <div class="compliance-score">
                <div class="score-number" id="overallScore">-</div>
                <div class="score-label">Overall Compliance</div>
            </div>
            <h1><i class="fas fa-shield-alt"></i> Validation & Compliance Dashboard</h1>
            <p>Software-Trackable Regulatory Compliance for qPCR Analysis</p>
        </div>

        <div class="controls">
            <div class="d-flex align-items-center gap-3">
                <button class="btn btn-primary" onclick="refreshDashboard()">
                    <i class="fas fa-sync-alt"></i> Refresh Data
                </button>
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="autoRefresh" checked>
                    <label class="form-check-label" for="autoRefresh">Auto Refresh</label>
                </div>
            </div>
            <div class="d-flex align-items-center gap-2">
                <span class="text-muted">Last Updated:</span>
                <span id="lastUpdate" class="fw-bold">-</span>
            </div>
        </div>

        <div class="dashboard-content">
            <!-- Overall Metrics -->
            <div class="container-fluid mt-4">
                <div class="row mb-4">
                    <div class="col-md-3">
                        <div class="metric-card">
                            <div class="metric-number" id="totalRequirements">-</div>
                            <div class="text-muted">Total Requirements</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="metric-card">
                            <div class="metric-number text-success" id="activeTracking">-</div>
                            <div class="text-muted">Currently Tracking</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="metric-card">
                            <div class="metric-number text-warning" id="readyToImplement">-</div>
                            <div class="text-muted">Ready to Implement</div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="metric-card">
                            <div class="metric-number text-info" id="evidenceCollected">-</div>
                            <div class="text-muted">Evidence Records</div>
                        </div>
                    </div>
                </div>

                <!-- Navigation Tabs -->
                <ul class="nav nav-pills justify-content-center mb-4" id="complianceTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="overview-tab" data-bs-toggle="pill" data-bs-target="#overview" type="button" role="tab">
                            <i class="fas fa-chart-pie"></i> Overview
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="organizations-tab" data-bs-toggle="pill" data-bs-target="#organizations" type="button" role="tab">
                            <i class="fas fa-building"></i> By Organization
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="evidence-tab" data-bs-toggle="pill" data-bs-target="#evidence" type="button" role="tab">
                            <i class="fas fa-file-alt"></i> Evidence Tracking
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="roadmap-tab" data-bs-toggle="pill" data-bs-target="#roadmap" type="button" role="tab">
                            <i class="fas fa-road"></i> Implementation Roadmap
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="ml-validation-tab" data-bs-toggle="pill" data-bs-target="#ml-validation" type="button" role="tab">
                            <i class="fas fa-brain"></i> ML Assisted Model Validation
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="export-tab" data-bs-toggle="pill" data-bs-target="#export" type="button" role="tab">
                            <i class="fas fa-download"></i> Export Reports
                        </button>
                    </li>
                </ul>

                <!-- Tab Content -->
                <div class="tab-content" id="complianceTabContent">
                    <!-- Overview Tab -->
                    <div class="tab-pane fade show active" id="overview" role="tabpanel">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="status-card status-active">
                                    <div class="card-body">
                                        <h5 class="card-title text-success">
                                            <i class="fas fa-check-circle"></i> Currently Tracking
                                        </h5>
                                        <p class="card-text">Requirements actively being monitored through app usage</p>
                                        <div id="activeRequirements"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="status-card status-partial">
                                    <div class="card-body">
                                        <h5 class="card-title text-warning">
                                            <i class="fas fa-clock"></i> Partial Implementation
                                        </h5>
                                        <p class="card-text">Requirements with some tracking in place</p>
                                        <div id="partialRequirements"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="status-card status-ready">
                                    <div class="card-body">
                                        <h5 class="card-title text-primary">
                                            <i class="fas fa-rocket"></i> Ready to Implement
                                        </h5>
                                        <p class="card-text">Technical implementation ready, will track when features added</p>
                                        <div id="readyRequirements"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="status-card status-planned">
                                    <div class="card-body">
                                        <h5 class="card-title text-info">
                                            <i class="fas fa-calendar-alt"></i> Planned Features
                                        </h5>
                                        <p class="card-text">Will track when user management features are implemented</p>
                                        <div id="plannedRequirements"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Organizations Tab -->
                    <div class="tab-pane fade" id="organizations" role="tabpanel">
                        <div id="organizationRequirements"></div>
                    </div>

                    <!-- Evidence Tab -->
                    <div class="tab-pane fade" id="evidence" role="tabpanel">
                        <div class="alert alert-info">
                            <i class="fas fa-info-circle"></i>
                            <strong>Evidence Tracking:</strong> Shows what evidence is being collected for each requirement and compliance gaps.
                        </div>
                        
                        <!-- Evidence Report Section (hidden by default) -->
                        <div id="evidenceReportSection" style="display: none;">
                            <div class="card mb-4">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <h5><i class="fas fa-file-alt"></i> <span id="evidenceReportTitle">Evidence Report</span></h5>
                                    <button class="btn btn-outline-secondary btn-sm" onclick="closeEvidenceReport()">
                                        <i class="fas fa-times"></i> Close Report
                                    </button>
                                </div>
                                <div class="card-body">
                                    <div id="evidenceReportContent">
                                        <!-- Dynamic evidence report content -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="evidenceTracking"></div>
                    </div>

                    <!-- Roadmap Tab -->
                    <div class="tab-pane fade" id="roadmap" role="tabpanel">
                        <div class="alert alert-primary">
                            <i class="fas fa-map"></i>
                            <strong>Implementation Roadmap:</strong> Features to implement for complete compliance tracking.
                        </div>
                        <div id="implementationRoadmap"></div>
                    </div>

                    <!-- ML Assisted Model Validation Tab -->
                    <div class="tab-pane fade" id="ml-validation" role="tabpanel">
                        <div class="ml-validation-section">
                            <h4><i class="fas fa-brain"></i> ML Assisted Model Validation & Version Control</h4>
                            <p>Comprehensive ML model management with version tracking, pathogen-specific performance, and validation workflow</p>
                            
                            <!-- ML Validation Workflow Steps -->
                            <div class="workflow-steps mb-4">
                                <div class="workflow-step">
                                    <i class="fas fa-brain fa-2x mb-2"></i>
                                    <h6>1. Auto-Captured</h6>
                                    <small>ML runs logged during analysis</small>
                                </div>
                                <div class="workflow-step">
                                    <i class="fas fa-check-circle fa-2x mb-2"></i>
                                    <h6>2. Confirm Runs</h6>
                                    <small>"All samples completed properly?"</small>
                                </div>
                                <div class="workflow-step">
                                    <i class="fas fa-chart-line fa-2x mb-2"></i>
                                    <h6>3. Track Performance</h6>
                                    <small>Version control & accuracy by pathogen</small>
                                </div>
                            </div>

                            <!-- ML Statistics Cards -->
                            <div class="row mb-4">
                                <div class="col-md-3">
                                    <div class="stat-card">
                                        <div class="stat-value text-warning" id="mlPendingCount">-</div>
                                        <div class="text-muted">Pending Confirmation</div>
                                        <i class="fas fa-clock text-warning float-end"></i>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="stat-card">
                                        <div class="stat-value text-success" id="mlConfirmedCount">-</div>
                                        <div class="text-muted">Confirmed Runs</div>
                                        <i class="fas fa-check text-success float-end"></i>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="stat-card">
                                        <div class="stat-value text-info" id="mlTotalModels">-</div>
                                        <div class="text-muted">Active Pathogen Models</div>
                                        <i class="fas fa-virus text-info float-end"></i>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="stat-card">
                                        <div class="stat-value text-primary" id="mlAvgAccuracy">-</div>
                                        <div class="text-muted">Average Accuracy</div>
                                        <i class="fas fa-percentage text-primary float-end"></i>
                                    </div>
                                </div>
                            </div>

                            <!-- ML Validation Tabs -->
                            <ul class="nav nav-pills mb-3" id="mlValidationTabs" role="tablist">
                                <li class="nav-item" role="presentation">
                                    <button class="nav-link active" id="ml-pending-tab" data-bs-toggle="pill" data-bs-target="#ml-pending" type="button" role="tab">
                                        <i class="fas fa-clock"></i> Pending Confirmation (<span id="mlPendingTabCount">0</span>)
                                    </button>
                                </li>
                                <li class="nav-item" role="presentation">
                                    <button class="nav-link" id="ml-confirmed-tab" data-bs-toggle="pill" data-bs-target="#ml-confirmed" type="button" role="tab">
                                        <i class="fas fa-check"></i> Confirmed Runs
                                    </button>
                                </li>
                                <li class="nav-item" role="presentation">
                                    <button class="nav-link" id="ml-models-tab" data-bs-toggle="pill" data-bs-target="#ml-models" type="button" role="tab">
                                        <i class="fas fa-virus"></i> Pathogen Models & Versions
                                    </button>
                                </li>
                            </ul>

                            <div class="tab-content" id="mlValidationTabContent">
                                <!-- Pending Confirmation Tab -->
                                <div class="tab-pane fade show active" id="ml-pending" role="tabpanel">
                                    <div class="card">
                                        <div class="card-header">
                                            <h6><i class="fas fa-clock text-warning"></i> Runs Waiting for Confirmation</h6>
                                            <small class="text-muted">Review each run and confirm if "all samples completed with proper results"</small>
                                        </div>
                                        <div class="card-body">
                                            <div id="mlPendingRunsList">
                                                <div class="text-center text-muted">
                                                    <i class="fas fa-spinner fa-spin"></i> Loading pending runs...
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Confirmed Runs Tab -->
                                <div class="tab-pane fade" id="ml-confirmed" role="tabpanel">
                                    <div class="card">
                                        <div class="card-header">
                                            <h6><i class="fas fa-check text-success"></i> Confirmed Runs with Accuracy Data</h6>
                                        </div>
                                        <div class="card-body">
                                            <div id="mlConfirmedRunsList">
                                                <div class="text-center text-muted">
                                                    <i class="fas fa-spinner fa-spin"></i> Loading confirmed runs...
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Pathogen Models & Version Control Tab -->
                                <div class="tab-pane fade" id="ml-models" role="tabpanel">
                                    <div class="card">
                                        <div class="card-header">
                                            <h6><i class="fas fa-virus text-info"></i> Pathogen Model Performance & Version Control</h6>
                                            <small class="text-muted">Version tracking, accuracy metrics, and training progress for each pathogen</small>
                                        </div>
                                        <div class="card-body">
                                            <div id="mlPathogenModels">
                                                <div class="text-center text-muted">
                                                    <i class="fas fa-spinner fa-spin"></i> Loading pathogen models...
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Export Tab -->
                    <div class="tab-pane fade" id="export" role="tabpanel">
                        <div class="export-section">
                            <h4><i class="fas fa-download"></i> Export Compliance Reports</h4>
                            <p>Generate detailed compliance reports for regulatory submissions and audits.</p>
                            
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card">
                                        <div class="card-body">
                                            <h6 class="card-title">Compliance Summary Report</h6>
                                            <p class="card-text">Overall compliance status with evidence summary</p>
                                            <button class="btn btn-primary" onclick="exportComplianceReport('summary')">
                                                <i class="fas fa-file-pdf"></i> Export PDF
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="card">
                                        <div class="card-body">
                                            <h6 class="card-title">Detailed Evidence Report</h6>
                                            <p class="card-text">Complete evidence documentation with audit trails</p>
                                            <button class="btn btn-success" onclick="exportComplianceReport('detailed')">
                                                <i class="fas fa-file-excel"></i> Export Excel
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card">
                                        <div class="card-body">
                                            <h6 class="card-title">Organization-Specific Reports</h6>
                                            <p class="card-text">Reports filtered by regulatory organization</p>
                                            <select class="form-select mb-2" id="orgFilter">
                                                <option value="all">All Organizations</option>
                                                <option value="FDA">FDA</option>
                                                <option value="CLIA">CLIA</option>
                                                <option value="CAP">CAP</option>
                                                <option value="ISO">ISO</option>
                                            </select>
                                            <button class="btn btn-info" onclick="exportOrganizationReport()">
                                                <i class="fas fa-filter"></i> Export Filtered
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="card">
                                        <div class="card-body">
                                            <h6 class="card-title">Implementation Roadmap</h6>
                                            <p class="card-text">Roadmap for future compliance features</p>
                                            <button class="btn btn-secondary" onclick="exportRoadmapReport()">
                                                <i class="fas fa-road"></i> Export Roadmap
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Requirement-specific evidence filtering utilities (cache-busted) -->
    <script src="/static/evidence_filter.js?v=20250819a"></script>
    <script>
        let complianceData = {};
        let evidenceData = {};
        let autoRefreshInterval;
        // Cache sessions for evidence counting/filtering
        window.cachedSessions = { confirmed: [], pending: [] };

        // Load dashboard data on page load
        document.addEventListener('DOMContentLoaded', function() {
            refreshDashboard();
            setupAutoRefresh();
        });

        function setupAutoRefresh() {
            const autoRefreshCheckbox = document.getElementById('autoRefresh');
            
            function toggleAutoRefresh() {
                if (autoRefreshCheckbox.checked) {
                    autoRefreshInterval = setInterval(refreshDashboard, 30000); // 30 seconds
                } else {
                    if (autoRefreshInterval) {
                        clearInterval(autoRefreshInterval);
                    }
                }
            }
            
            autoRefreshCheckbox.addEventListener('change', toggleAutoRefresh);
            toggleAutoRefresh(); // Initial setup
        }

    async function refreshDashboard() {
            try {
                // Load compliance data from unified compliance manager
                const [dashboardResponse, requirementsResponse, confirmedResp, pendingResp] = await Promise.all([
                    fetch('/api/unified-compliance/summary'),
                    fetch('/api/unified-compliance/requirements'),
                    fetch('/api/sessions/confirmed'),
                    fetch('/api/sessions/pending')
                ]);

                const dashboardData = await dashboardResponse.json();
                const requirementsResponse_data = await requirementsResponse.json();
                const confirmedData = await confirmedResp.json();
                const pendingData = await pendingResp.json();

                // Store dashboard and requirements data
                window.dashboardData = dashboardData;
                window.requirementsData = requirementsResponse_data.requirements || [];
                
                // Map backend implementation_status to dashboard groups
                // Groups: active, partial, ready_to_implement, planned
                function mapToGroup(req) {
                    const status = (req.implementation_status || '').toLowerCase();
                    if (status === 'validated' || status === 'completed') return 'active';
                    if (status === 'in_progress') return 'partial';
                    if (status === 'not_started') return req.auto_trackable ? 'ready_to_implement' : 'planned';
                    return 'planned';
                }

                // Group detailed requirements into dashboard groups so evidence fields remain available
                complianceData = { active: [], partial: [], ready_to_implement: [], planned: [] };
                for (const req of window.requirementsData) {
                    const group = mapToGroup(req);
                    complianceData[group].push(req);
                }
                
                // Store evidence data from requirements
                evidenceData = {};
                window.requirementsData.forEach(req => {
                    if (req.evidence_count > 0) {
                        evidenceData[req.id] = {
                            count: req.evidence_count,
                            evidence_types: req.evidence_types || [],
                            last_updated: req.last_updated
                        };
                    }
                });
                
                // Store the total count from the requirements response
                window.totalRequirementsCount = requirementsResponse_data.total_count || window.requirementsData.length || 0;

                // Cache sessions for evidence filtering
                window.cachedSessions = {
                    confirmed: (confirmedData && (confirmedData.confirmed_sessions || confirmedData.sessions || [])) || [],
                    pending: (pendingData && (pendingData.pending_sessions || pendingData.sessions || [])) || []
                };

                // Preload encryption evidence presence for any requirement whose allowed types include encryption_evidence
                window.encryptionPresenceByReq = {};
                try {
                    const reqs = Array.isArray(window.requirementsData) ? window.requirementsData : [];
                    const encReqs = reqs.filter(r => {
                        try {
                            const allowed = window.EvidenceFilter?.getAllowedEvidenceTypes?.(r.id) || [];
                            return allowed.includes('encryption_evidence');
                        } catch { return false; }
                    });
                    if (encReqs.length > 0) {
                        await Promise.all(encReqs.map(async (r) => {
                            try {
                                const res = await fetch(`/api/unified-compliance/encryption-evidence/${r.id}`);
                                const data = res.ok ? await res.json() : null;
                                window.encryptionPresenceByReq[r.id] = data && data.success ? data : null;
                            } catch (e) {
                                console.warn('Encryption preload failed for', r.id, e);
                                window.encryptionPresenceByReq[r.id] = null;
                            }
                        }));
                    }
                } catch (e) {
                    console.warn('Encryption presence preload skipped:', e);
                }

                // Preload audit logs once if any requirement needs them so overview counts include logs
                try {
                    const mapping = window.EvidenceFilter?.REQUIREMENT_EVIDENCE_MAPPING || {};
            const needsAudit = (window.requirementsData || []).some(r => Array.isArray(mapping[r.id]) && mapping[r.id].includes('audit_logs'));
                    if (needsAudit) {
                        try {
                // Use auth audit log for access/Entra evidence
                const res = await fetch('/api/auth/audit-log?limit=200');
                            window.auditLogCache = res.ok ? await res.json() : null;
                        } catch (e) {
                            console.warn('Audit log preload failed:', e);
                            window.auditLogCache = null;
                        }
                    } else {
                        window.auditLogCache = null;
                    }
                } catch (e) {
                    console.warn('Audit preload skipped:', e);
                }

                // Helper to compute evidence count for a requirement using cached sessions and preloaded encryption presence
                function getEvidenceCountForReq(reqId) {
                    try {
                        const confirmed = window.cachedSessions?.confirmed || [];
                        const pending = window.cachedSessions?.pending || [];
                        const encData = (window.encryptionPresenceByReq || {})[reqId] || null;
                        const req = (window.requirementsData || []).find(r => r.id === reqId) || {};
                        const sources = Array.isArray(req.evidence_sources) ? req.evidence_sources : [];
                        const auditLogs = window.auditLogCache || null;
                        if (window.EvidenceFilter?.getRelevantEvidenceCount) {
                            return window.EvidenceFilter.getRelevantEvidenceCount(reqId, confirmed, pending, encData, sources, auditLogs) || 0;
                        }
                    } catch {}
                    return 0;
                }

                // Rebuild compliance groups factoring in evidence presence (bumps to 'partial' when evidence exists)
                try {
                    const prev = complianceData;
                    complianceData = { active: [], partial: [], ready_to_implement: [], planned: [] };
                    for (const req of window.requirementsData) {
                        const status = (req.implementation_status || '').toLowerCase();
                        const evidenceCount = getEvidenceCountForReq(req.id);
                        let group = 'planned';
                        if (status === 'validated' || status === 'completed') group = 'active';
                        else if (status === 'in_progress') group = 'partial';
                        else if (evidenceCount > 0) group = 'partial';
                        else if (status === 'not_started') group = req.auto_trackable ? 'ready_to_implement' : 'planned';
                        complianceData[group].push(req);
                    }
                } catch (e) {
                    console.warn('Evidence-aware regroup skipped:', e);
                }

                updateMetrics();
                updateOverviewTab();
                updateOrganizationsTab();
                updateEvidenceTab();
                updateRoadmapTab();
                updateLastRefresh();

            } catch (error) {
                console.error('Error loading compliance data:', error);
                showAlert('Error loading compliance data', 'danger');
            }
        }

        function updateLastRefresh() {
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

    function updateMetrics() {
            // Use the unified compliance data
            const total = window.totalRequirementsCount || 0;
            const dashboardData = window.dashboardData || {};
            const requirementsData = window.requirementsData || [];
            
            // Derive Currently Tracking from grouped implementation statuses to keep groups exclusive
            // active + partial are considered currently tracking; ready_to_implement/planned are not
            const currentlyTracking = (complianceData.active?.length || 0) + (complianceData.partial?.length || 0);
            // Use deduplicated global evidence count when available; fallback to backend summary
            let totalEvidence = 0;
            try {
                if (window.EvidenceFilter?.getGlobalEvidenceCount) {
                    totalEvidence = window.EvidenceFilter.getGlobalEvidenceCount(
                        window.requirementsData || [],
                        window.cachedSessions || { confirmed: [], pending: [] },
                        window.encryptionPresenceByReq || {}
                    ) || 0;
                } else {
                    totalEvidence = dashboardData.total_events || 0;
                }
            } catch {
                totalEvidence = dashboardData.total_events || 0;
            }
            
            // Calculate display groups using complianceData
            const readyToImplementCount = (complianceData.ready_to_implement || []).length;
            
            // Overall compliance percentage from dashboard data
            const overallCompliancePercent = total > 0 ? 
                Math.round((currentlyTracking / total) * 100) : 0;

            // Update the display
            document.getElementById('totalRequirements').textContent = total;
            document.getElementById('activeTracking').textContent = currentlyTracking;
            document.getElementById('readyToImplement').textContent = readyToImplementCount; // Ready to implement group
            document.getElementById('evidenceCollected').textContent = totalEvidence;
            document.getElementById('overallScore').textContent = overallCompliancePercent + '%';
        }

        function updateOverviewTab() {
            updateRequirementSection('activeRequirements', complianceData.active || []);
            updateRequirementSection('partialRequirements', complianceData.partial || []);
            updateRequirementSection('readyRequirements', complianceData.ready_to_implement || []);
            updateRequirementSection('plannedRequirements', complianceData.planned || []);
            
            // Also show completed requirements in the active section
            if (complianceData.completed && complianceData.completed.length > 0) {
                updateRequirementSection('activeRequirements', [
                    ...(complianceData.active || []),
                    ...complianceData.completed
                ]);
            }
        }

        function updateRequirementSection(elementId, requirements) {
            const element = document.getElementById(elementId);
            if (!element) return;

            if (requirements.length === 0) {
                element.innerHTML = '<p class="text-muted"><em>No requirements in this category</em></p>';
                return;
            }

            element.innerHTML = requirements.map(req => `
                <div class="requirement-item" onclick="toggleRequirement('${req.id}')">
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <strong>${req.title}</strong>
                            <br><small class="text-muted">${req.category || 'General'}</small>
                        </div>
                        <div class="evidence-badges">
                            ${getEvidenceBadges(req.id)}
                        </div>
                    </div>
                    <div id="detail-${req.id}" class="requirement-details" style="display: none;">
                        <hr>
                        <p><strong>Description:</strong> ${req.description}</p>
                        <div class="evidence-detail">
                            <h6>Evidence Types:</h6>
                            <div class="d-flex flex-wrap">
                                ${(req.evidence_types || []).map(type => `
                                    <span class="badge bg-info me-1 mb-1">${type}</span>
                                `).join('')}
                            </div>
                            <h6>Auto Trackable:</h6>
                            <span class="badge ${req.auto_trackable ? 'bg-success' : 'bg-secondary'}">${req.auto_trackable ? 'Yes' : 'No'}</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function updateOrganizationsTab() {
            const orgContainer = document.getElementById('organizationRequirements');
            const orgData = {};

            // Group requirements by category (since we don't have organization field)
            Object.values(complianceData).flat().forEach(req => {
                const category = req.category || 'General';
                if (!orgData[category]) {
                    orgData[category] = [];
                }
                orgData[category].push(req);
            });

            orgContainer.innerHTML = Object.entries(orgData).map(([category, reqs]) => `
                <div class="regulation-section">
                    <h3><i class="fas fa-building"></i> ${category}</h3>
                    <div class="row">
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-number">${reqs.length}</div>
                                <div class="text-muted">Total Requirements</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-number text-success">${reqs.filter(r => getImplementationStatus(r) === 'active').length}</div>
                                <div class="text-muted">Active</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-number text-warning">${reqs.filter(r => getImplementationStatus(r) === 'partial').length}</div>
                                <div class="text-muted">Partial</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-number text-primary">${reqs.filter(r => ['ready_to_implement', 'planned'].includes(getImplementationStatus(r))).length}</div>
                                <div class="text-muted">Planned</div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-3">
                        ${reqs.map(req => `
                            <div class="requirement-item">
                                <div class="d-flex justify-content-between align-items-start">
                                    <div>
                                        <strong>${req.title}</strong>
                                        <br><small class="text-muted">${req.category}</small>
                                        <br><small>${req.description}</small>
                                    </div>
                                    <div>
                                        <span class="badge bg-${getStatusColor(getImplementationStatus(req))}">${getImplementationStatus(req)}</span>
                                        ${getEvidenceBadges(req.id)}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }

    function updateEvidenceTab() {
            const evidenceContainer = document.getElementById('evidenceTracking');
            const confirmed = window.cachedSessions?.confirmed || [];
            const pending = window.cachedSessions?.pending || [];

            evidenceContainer.innerHTML = Object.values(complianceData).flat().map(req => {
                // Use EvidenceFilter for requirement-specific counts
                let evidenceCount = 0;
                try {
            const encData = (window.encryptionPresenceByReq || {})[req.id] || null;
            const sources = Array.isArray(req.evidence_sources) ? req.evidence_sources : [];
            const auditLogs = window.auditLogCache || null;
            evidenceCount = window.EvidenceFilter?.getRelevantEvidenceCount?.(req.id, confirmed, pending, encData, sources, auditLogs) || 0;
                } catch { evidenceCount = 0; }
                const hasEvidence = evidenceCount > 0;

                return `
                    <div class="requirement-item">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="flex-grow-1">
                                <h6>${req.title}</h6>
                                <p class="text-muted mb-2">${req.category || 'General'}</p>
                                <p class="mb-2">${req.description}</p>
                                
                                <div class="evidence-detail">
                                    <div class="row">
                                        <div class="col-md-6">
                                            <strong>Evidence Types:</strong><br>
                                            <small>${(req.evidence_types || []).join(', ')}</small>
                                        </div>
                                        <div class="col-md-6">
                                            <strong>Evidence Count:</strong><br>
                                            <span class="badge ${hasEvidence ? 'bg-success' : 'bg-danger'} fs-6">
                                                ${evidenceCount} records
                                            </span>
                                        </div>
                                    </div>
                                    
                                    ${(req.evidence_types || []).length ? `
                                        <div class="mt-2">
                                            ${(req.evidence_types || []).map(type => {
                                                return `<span class=\"badge bg-info me-1 mb-1\">${type}</span>`;
                                            }).join('')}
                                        </div>
                                    ` : ''}

                                    <div class="mt-2">
                                        <strong>Evidence Category:</strong>
                                        ${(() => {
                                            try {
                                                const badge = window.EvidenceFilter?.getEvidenceTypeBadge?.(req.id);
                                                if (badge) return `<span class=\"badge ${badge.class} ms-1\">${badge.text}</span>`;
                                            } catch {}
                                            return '<span class=\"badge bg-secondary\">General Evidence</span>';
                                        })()}
                                    </div>
                                    
                                    ${req.last_updated ? `
                                        <div class="mt-2">
                                            <strong>Latest Activity:</strong> ${new Date(req.last_updated).toLocaleString()}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                            <div class="text-end">
                                ${getEvidenceBadges(req.id)}
                                <br>
                                <button class="btn btn-sm btn-outline-primary mt-2" onclick="showSimpleEvidence('${req.id}', ${evidenceCount})">
                                    <i class="fas fa-eye"></i> View Evidence (${evidenceCount})
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateRoadmapTab() {
            const roadmapContainer = document.getElementById('implementationRoadmap');
            
            const roadmapItems = Object.values(complianceData).flat()
                .sort((a, b) => {
                    const order = { 'ready_to_implement': 1, 'planned': 2, 'partial': 3, 'active': 4 };
                    return order[getImplementationStatus(a)] - order[getImplementationStatus(b)];
                });

            roadmapContainer.innerHTML = roadmapItems.map(req => `
                <div class="roadmap-item">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <h6>${req.title}</h6>
                        <span class="badge bg-${getStatusColor(getImplementationStatus(req))}">${getImplementationStatus(req)}</span>
                    </div>
                    <p class="text-muted mb-2">${req.category} - ${req.description}</p>
                    <div>
                        <strong>Evidence Types:</strong>
                        ${(req.evidence_types || []).map(type => `
                            <span class="badge bg-info me-1 mb-1">${type}</span>
                        `).join('')}
                    </div>
                    <div class="mt-2">
                        <strong>Auto Trackable:</strong>
                        <span class="badge ${req.auto_trackable ? 'bg-success' : 'bg-secondary'} me-1">${req.auto_trackable ? 'Yes' : 'No'}</span>
                    </div>
                </div>
            `).join('');
        }

        // Helper functions
        function getImplementationStatus(req) {
            // Find which category this requirement is in
            for (const [status, reqs] of Object.entries(complianceData)) {
                if (Array.isArray(reqs) && reqs.some(r => r.id === req.id)) {
                    return status;
                }
            }
            return 'unknown';
        }

        function getStatusColor(status) {
            const colors = {
                'active': 'success',
                'partial': 'warning', 
                'ready_to_implement': 'primary',
                'planned': 'info',
                'unknown': 'secondary'
            };
            return colors[status] || 'secondary';
        }

        function getEvidenceBadges(reqCode) {
            // Compute requirement-specific evidence count using EvidenceFilter and cached sessions
            const confirmed = window.cachedSessions?.confirmed || [];
            const pending = window.cachedSessions?.pending || [];
            let evidenceCount = 0;
            try {
                if (window.EvidenceFilter?.getRelevantEvidenceCount) {
                    const encData = (window.encryptionPresenceByReq || {})[reqCode] || null;
                    const req = window.requirementsData.find(r => r.id === reqCode) || {};
                    const sources = Array.isArray(req.evidence_sources) ? req.evidence_sources : [];
                    const auditLogs = window.auditLogCache || null;
                    evidenceCount = window.EvidenceFilter.getRelevantEvidenceCount(reqCode, confirmed, pending, encData, sources, auditLogs);
                } else {
                    const req = window.requirementsData.find(r => r.id === reqCode);
                    evidenceCount = req ? (Array.isArray(req.evidence_sources) ? req.evidence_sources.length : (req.evidence_count || 0)) : 0;
                }
            } catch (e) {
                console.warn('Evidence badge computation failed, using fallback:', e);
                const req = window.requirementsData.find(r => r.id === reqCode);
                evidenceCount = req ? (Array.isArray(req.evidence_sources) ? req.evidence_sources.length : (req.evidence_count || 0)) : 0;
            }

            const hasEvidence = evidenceCount > 0;

            // Evidence category badge (software_validation, data_protection, etc.)
            let typeBadgeClass = 'bg-secondary', typeBadgeText = 'General Evidence';
            try {
                const badge = window.EvidenceFilter?.getEvidenceTypeBadge?.(reqCode);
                if (badge) {
                    typeBadgeClass = badge.class || typeBadgeClass;
                    typeBadgeText = badge.text || typeBadgeText;
                }
            } catch {}

            return `
                <span class="evidence-badge ${hasEvidence ? 'evidence-found' : 'evidence-missing'}">
                    ${hasEvidence ? `Evidence Found (${evidenceCount})` : 'No Evidence'}
                </span>
                <span class="badge ${typeBadgeClass} ms-1">${typeBadgeText}</span>
            `;
        }

        

        function showSimpleEvidence(reqCode, evidenceCount) {
            // Find the requirement
            const req = window.requirementsData.find(r => r.id === reqCode);
            if (!req) {
                showAlert('Requirement not found', 'danger');
                return;
            }
            
            // Create a simple evidence modal with loading state
            const modalHTML = `
                <div class="modal fade" id="evidenceModal" tabindex="-1">
                    <div class="modal-dialog modal-xl">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">Evidence for ${reqCode}</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                <h6>${req.title}</h6>
                                <p class="text-muted">${req.description}</p>
                                
                <div class="alert alert-info" id="evidenceCountSummary">
                                    <strong>Evidence Count:</strong> <span id="evidenceCountValue">${evidenceCount}</span> records found<br>
                                    <strong>Implementation Status:</strong> ${req.implementation_status}<br>

                                    <div class="mt-2">
                                        <strong>Evidence Category:</strong>
                    ${(() => {
                                            try {
                                                const badge = window.EvidenceFilter?.getEvidenceTypeBadge?.(req.id);
                        if (badge) return `<span id="evidenceCategoryBadge" class="badge ${badge.class} ms-1">${badge.text}</span>`;
                                            } catch {}
                        return '<span id="evidenceCategoryBadge" class="badge bg-secondary">General Evidence</span>';
                                        })()}
                                    </div>
                                    <strong>Evidence Types:</strong> ${(req.evidence_types || []).join(', ')}
                                </div>
                <div id="policyGuidance" class="mb-2"></div>
                                
                                ${(() => {
                                    try {
                                        const types = window.EvidenceFilter?.getAllowedEvidenceTypes?.(req.id) || [];
                                        if (types.includes('run_files') || types.includes('validation_tests')) {
                                            return `
                                                <div class="alert alert-success">
                                                    <i class="fas fa-check-circle"></i>
                                                    <strong>Validation System Tracking:</strong> This requirement is actively being tracked by the validation system. Evidence is being collected automatically during qPCR analysis runs.
                                                </div>`;
                                        }
                                    } catch {}
                                    return '';
                                })()}
                                
                                <div id="evidenceDetails">
                                    <div class="text-center py-4">
                                        <i class="fas fa-spinner fa-spin fa-2x"></i>
                                        <p class="mt-2">Loading evidence records...</p>
                                    </div>
                                </div>
                                
                                ${req.last_updated ? `
                                    <div class="mt-2">
                                        <strong>Last Updated:</strong> ${new Date(req.last_updated).toLocaleString()}
                                    </div>
                                ` : ''}
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove any existing modal
            const existingModal = document.getElementById('evidenceModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Add the modal to the page
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('evidenceModal'));
            modal.show();
            
            // Load actual evidence records
            loadEvidenceDetails(reqCode);
            // Render per-requirement guidance and configurator
            try { renderEvidenceGuidance(req); } catch (e) { console.warn('Guidance render skipped:', e); }
        }

        // Centralized handlers for policy configurator actions
        function savePolicyOverride(reqId) {
            try {
                const container = document.getElementById('policyConfigurator');
                const boxes = container ? container.querySelectorAll('input.form-check-input[type="checkbox"]') : [];
                const sel = Array.from(boxes).filter(b => b.checked).map(b => b.value || (b.id || '').replace(/^cfg_/, ''));
                const ok = window.EvidenceFilter?.setPolicyOverride?.(reqId, sel);
                if (ok) {
                    try {
                        const b = window.EvidenceFilter.getEvidenceTypeBadge(reqId);
                        const el = document.getElementById('evidenceCategoryBadge');
                        if (b && el) { el.className = 'badge ' + b.class + ' ms-1'; el.textContent = b.text; }
                    } catch {}
                    loadEvidenceDetails(reqId);
                    // Refresh outer sections so badges/counts align with new policy
                    try { updateOverviewTab(); } catch {}
                    try { updateEvidenceTab(); } catch {}
                    try { updateOrganizationsTab(); } catch {}
                }
            } catch (e) { console.warn('Policy save failed', e); }
        }

        function clearPolicyOverrideAndReload(reqId) {
            try { window.EvidenceFilter?.clearPolicyOverride?.(reqId); } catch {}
            try {
                const b = window.EvidenceFilter.getEvidenceTypeBadge(reqId);
                const el = document.getElementById('evidenceCategoryBadge');
                if (b && el) { el.className = 'badge ' + b.class + ' ms-1'; el.textContent = b.text; }
            } catch {}
            try { loadEvidenceDetails(reqId); } catch {}
            try { updateOverviewTab(); } catch {}
            try { updateEvidenceTab(); } catch {}
            try { updateOrganizationsTab(); } catch {}
        }

        function renderEvidenceGuidance(req) {
            const host = document.getElementById('policyGuidance');
            if (!host) return;
            let allowed = [];
            try { allowed = window.EvidenceFilter?.getAllowedEvidenceTypes?.(req.id) || []; } catch { allowed = []; }
            const examples = {
                run_files: 'qPCR analysis run files (confirmed sessions, standardized run artifacts)',
                validation_tests: 'Software validation test outputs (harness logs, pass/fail summaries)',
                encryption_evidence: 'Encryption controls (TLS/HTTPS logs, encryption API evidence, config excerpts)',
                audit_logs: 'Access/activity logs and audit trail entries (role assignment changes, login attempts)',
                documentation: 'SOPs, policies, and versioned procedural documentation',
                risk_management: 'Risk assessments and mitigation records'
            };
            const allTypes = ['run_files','validation_tests','encryption_evidence','audit_logs','documentation','risk_management'];
            const badgeFor = (t) => {
                const map = {
                    run_files: ['bg-primary','Run Files'],
                    validation_tests: ['bg-primary','Validation Tests'],
                    encryption_evidence: ['bg-success','Encryption'],
                    audit_logs: ['bg-warning text-dark','Audit Logs'],
                    documentation: ['bg-info','Documentation'],
                    risk_management: ['bg-secondary','Risk Mgmt']
                }; return map[t] || ['bg-secondary','General'];
            };

            const selected = new Set(allowed);
            const badges = allowed.map(t => {
                const [cls, txt] = badgeFor(t); return `<span class="badge ${cls} me-1">${txt}</span>`;
            }).join(' ');
            const tips = allowed.map(t => `<li>${examples[t]}</li>`).join('');

            host.innerHTML = `
                <div class="alert alert-light border">
                    <div class="d-flex justify-content-between align-items-start flex-wrap">
                        <div class="me-2">
                            <strong>What counts as evidence for this requirement?</strong><br>
                            ${badges || '<span class="badge bg-secondary">Unspecified</span>'}
                            ${tips ? `<ul class="mb-0 mt-2">${tips}</ul>` : '<small class="text-muted">Use the configurator to choose expected evidence types for this requirement.</small>'}
                        </div>
                        <div>
                            <button class="btn btn-sm btn-outline-secondary" type="button" onclick="(function(){ const el=document.getElementById('policyConfigurator'); el.style.display = (el.style.display==='none'?'block':'none'); })()">Configure</button>
                        </div>
                    </div>
                    <div id="policyConfigurator" class="mt-2" style="display: none;">
                        <div class="row g-2">
                            ${allTypes.map(t => {
                                const checked = selected.has(t) ? 'checked' : '';
                                const [cls, txt] = badgeFor(t);
                                return `
                                    <div class=\"col-md-4\">
                                        <div class=\"form-check\">
                                            <input class=\"form-check-input\" type=\"checkbox\" id=\"cfg_${t}\" value=\"${t}\" ${checked}>
                                            <label class=\"form-check-label\" for=\"cfg_${t}\">
                                                <span class=\"badge ${cls}\">${txt}</span>
                                            </label>
                                        </div>
                                        <small class=\"text-muted\">${examples[t]}</small>
                                    </div>`;
                            }).join('')}
                        </div>
                        <div class="mt-3 d-flex gap-2">
                            <button class="btn btn-sm btn-primary" onclick="savePolicyOverride('${req.id}')">Save</button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="clearPolicyOverrideAndReload('${req.id}')">Clear Override</button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function loadEvidenceDetails(reqCode) {
            // Get requirement data with evidence_sources from the stored data
            const requirement = window.requirementsData?.find(req => req.id === reqCode);
            const evidenceContainer = document.getElementById('evidenceDetails');
            if (!evidenceContainer) return;
            // Track session IDs represented in evidence_sources to avoid duplicate rendering later
            let coveredSessionIds = new Set();
            // Ensure we have a safe default for renderSources even when evidence_sources path is not taken
            let renderSources = [];
            // Simple, per-page-session cache for validation test results
            try { window.__validationCache = window.__validationCache || null; } catch {}
            
            // If we have evidence_sources from the API, use those instead of the old method
            if (requirement && requirement.evidence_sources && requirement.evidence_sources.length > 0) {
                console.log('Using new evidence_sources for', reqCode, ':', requirement.evidence_sources.length, 'sources');

                // Group repeated Data Integrity/File Validation entries by day to reduce noise
                // Also filter to category-appropriate entries for this requirement
                const allSources = Array.isArray(requirement.evidence_sources) ? requirement.evidence_sources.slice() : [];
                const rawSources = allSources.filter(s => {
                    try {
                        return window.EvidenceFilter?.shouldIncludeSourceForRequirement?.(reqCode, s) ?? true;
                    } catch { return true; }
                });
                renderSources = (() => {
                    // Group by YYYY-MM-DD for integrity/validation types
                    const groups = new Map();
                    const others = [];
                    let integrityRawCount = 0; // count raw integrity items before grouping
                    for (const s of rawSources) {
                        const et = (s.evidence_type || '').toLowerCase();
                        const isIntegrity = et.includes('data integrity') || et.includes('file validation');
                        if (!isIntegrity) { others.push(s); continue; }
                        integrityRawCount++;
                        let dateKey = 'unknown';
                        try {
                            const d = new Date(s.created_at || s.updated_at || Date.now());
                            if (!isNaN(d.getTime())) dateKey = d.toISOString().slice(0,10);
                        } catch {}
                        const key = `${et}__${dateKey}`;
                        if (!groups.has(key)) groups.set(key, []);
                        groups.get(key).push(s);
                    }
                    // Expose duplicate summary for integrity items
                    const grouped = [];
                    const integrityGroupSummaries = [];
                    for (const [key, list] of groups.entries()) {
                        // Determine aggregate status and latest timestamp
                        let status = 'pending';
                        let ts = 0;
                        for (const item of list) {
                            const badgeStatus = (item.confirmation_status || item.validation_status || 'pending').toLowerCase();
                            if (badgeStatus === 'validated' || badgeStatus === 'confirmed') status = 'validated';
                            const t = new Date(item.created_at || item.updated_at || Date.now()).getTime();
                            if (t > ts) ts = t;
                        }
                        const latest = new Date(ts || Date.now()).toISOString();
                        const sample = list[0] || {};
                        // Capture summary for duplicates listing UI
                        try {
                            const parts = (key || '').split('__');
                            const dateOnly = parts.length > 1 ? parts[1] : 'unknown';
                            integrityGroupSummaries.push({
                                date: dateOnly,
                                count: list.length,
                                type: sample.evidence_type || 'Data integrity checks and file validation logs'
                            });
                        } catch {}
                        grouped.push({
                            evidence_type: sample.evidence_type || 'Data integrity checks and file validation logs',
                            description: sample.description || 'N/A',
                            validation_status: status,
                            created_at: latest,
                            __group_count: list.length
                        });
                    }
                    // Attach deduplication meta on window for later rendering in this scope
                    const uniqueIntegrityGroups = groups.size;
                    const rawEvidenceSourcesCount = integrityRawCount + others.length;
                    const uniqueEvidenceSourcesCount = grouped.length + others.length;
                    // Stash on a local object we return alongside the list
                    return Object.assign(
                        [...grouped, ...others].sort((a,b) => new Date(b.created_at||0) - new Date(a.created_at||0)),
                        {
                            __dedup_meta: {
                                integrityRawCount,
                                uniqueIntegrityGroups,
                                rawEvidenceSourcesCount,
                                uniqueEvidenceSourcesCount,
                                integrityGroupSummaries
                            }
                        }
                    );
                })();

                // Populate coveredSessionIds from Analysis Session entries listed in evidence_sources
                try {
                    coveredSessionIds = new Set();
                    const scanList = Array.from(renderSources);
                    for (const item of scanList) {
                        const et = (item.evidence_type || '').toLowerCase();
                        if (et.includes('analysis session')) {
                            // Prefer explicit session_id field if provided
                            if (typeof item.session_id === 'number') {
                                coveredSessionIds.add(item.session_id);
                            } else {
                                const hint = (item.description || item.filename || '');
                                const m = /Session:\s*(\d+)/i.exec(hint);
                                if (m) {
                                    const sid = parseInt(m[1], 10);
                                    if (!Number.isNaN(sid)) coveredSessionIds.add(sid);
                                }
                            }
                        }
                    }
                } catch {}

                let evidenceHTML = '';
                if (renderSources.length > 0) {
                    evidenceHTML += `
                        <div class="card">
                            <div class="card-header">
                                <h6 class="mb-0"><i class="fas fa-database"></i> Evidence Records (${renderSources.length})</h6>
                            </div>
                            <div class="card-body">
                                ${(() => {
                                try {
                                    const m = renderSources.__dedup_meta || {};
                                    if (!m || typeof m.rawEvidenceSourcesCount !== 'number') return '';
                                    const dup = Math.max(0, (m.integrityRawCount - m.uniqueIntegrityGroups));
                                    const anyDup = dup > 0;
                                    const listId = `dupList-${reqCode}`;
                                    return `
                                        <div class="mb-3">
                                            <small class="text-muted">
                                                Raw evidence sources: <strong>${m.rawEvidenceSourcesCount}</strong> • Unique after grouping: <strong>${m.uniqueEvidenceSourcesCount}</strong>
                                                ${anyDup ? `
                                                    <br>
                                                    <span class="text-muted">${dup} duplicates from repeated Data Integrity/File Validation checks</span>
                                                    &nbsp; <a href="#" onclick="(function(){ const el = document.getElementById('${listId}'); if (el) { el.style.display = (el.style.display==='none'?'block':'none'); } })(); return false;">${'Show details'}</a>
                                                    <div id="${listId}" style="display: none;" class="mt-2">
                                                        <ul class="mb-2">
                                                            ${(m.integrityGroupSummaries || []).map(g => `
                                                                <li><small>${g.type} — ${g.date}: <strong>${g.count}</strong> checks</small></li>
                                                            `).join('')}
                                                        </ul>
                                                        <small class="text-muted">We group repeated integrity checks by day to avoid noisy duplicate counting. The table below shows grouped entries; click to expand for raw logs if needed.</small>
                                                    </div>
                                                ` : ''}
                                            </small>
                                        </div>
                                    `;
                                } catch { return ''; }
                            })()}
                                <div class="table-responsive">
                                    <table class="table table-sm table-striped">
                                        <thead>
                                            <tr>
                                                <th>Type</th>
                                                <th>Description</th>
                                                <th>Status</th>
                                                <th>Date</th>
                                            </tr>
                                        </thead>
                                        <tbody>`;
                
                renderSources.forEach((source, index) => {
                    let statusBadge = source.confirmation_status === 'confirmed' ? 
                        'bg-success' : source.validation_status === 'validated' ? 
                        'bg-success' : 'bg-warning';
                    let statusText = source.confirmation_status || source.validation_status || 'pending';
                    
                    // Heuristic: Data integrity/file validation logs are produced by completed checks.
                    // If no explicit status is present, treat them as validated unless a failure is detected.
                    try {
                        const et = (source.evidence_type || '').toLowerCase();
                        if ((et.includes('data integrity') || et.includes('file validation')) && (statusText === 'pending' || statusText === 'unknown')) {
                            let evidence = null;
                            if (typeof source.evidence_data === 'string') {
                                try { evidence = JSON.parse(source.evidence_data); } catch {}
                            } else if (typeof source.evidence_data === 'object') {
                                evidence = source.evidence_data;
                            }
                            let hasFailure = false;
                            let hasSuccess = false;
                            if (evidence) {
                                const vr = evidence.validation_results || evidence.results || {};
                                const sv = evidence.system_verification || {};
                                // Signals for failures/success
                                if (typeof vr.errors === 'number' && vr.errors > 0) hasFailure = true;
                                if (vr.failed || vr.status === 'FAIL') hasFailure = true;
                                if (sv.overall_status === 'FAIL' || sv.pass === false) hasFailure = true;
                                if (vr.success === true || vr.status === 'PASS') hasSuccess = true;
                                if (sv.overall_status === 'PASS' || sv.pass === true) hasSuccess = true;
                            }
                            if (hasFailure) {
                                statusBadge = 'bg-danger';
                                statusText = 'failed';
                            } else {
                                statusBadge = 'bg-success';
                                statusText = 'validated';
                            }
                        }
                    } catch {}
                    const dateStr = source.created_at ? new Date(source.created_at).toLocaleDateString() : 'N/A';
                    
                    // Parse evidence_data JSON to get enhanced descriptions
                    let description = source.description || source.filename || 'N/A';
                    try {
                        if (source.evidence_data && typeof source.evidence_data === 'string') {
                            const evidenceData = JSON.parse(source.evidence_data);
                            // Try multiple fields for enhanced descriptions
                            if (evidenceData.description && evidenceData.description !== 'N/A') {
                                description = evidenceData.description;
                            } else if (evidenceData.technical_specifications && evidenceData.technical_specifications.description) {
                                description = evidenceData.technical_specifications.description;
                            } else if (evidenceData.system_verification && evidenceData.system_verification.verification_summary) {
                                description = evidenceData.system_verification.verification_summary;
                            } else if (evidenceData.regulatory_mapping && evidenceData.regulatory_mapping.evidence_statement) {
                                description = evidenceData.regulatory_mapping.evidence_statement;
                            } else if (evidenceData.encryption_algorithm) {
                                // Build description from encryption details
                                const parts = [];
                                if (evidenceData.encryption_algorithm) parts.push(`Algorithm: ${evidenceData.encryption_algorithm}`);
                                if (evidenceData.key_derivation) parts.push(`Key Derivation: ${evidenceData.key_derivation}`);
                                if (parts.length > 0) description = parts.join(', ');
                            }
                        } else if (source.evidence_data && typeof source.evidence_data === 'object') {
                            const evidenceData = source.evidence_data;
                            // Try multiple fields for enhanced descriptions
                            if (evidenceData.description && evidenceData.description !== 'N/A') {
                                description = evidenceData.description;
                            } else if (evidenceData.technical_specifications && evidenceData.technical_specifications.description) {
                                description = evidenceData.technical_specifications.description;
                            } else if (evidenceData.system_verification && evidenceData.system_verification.verification_summary) {
                                description = evidenceData.system_verification.verification_summary;
                            } else if (evidenceData.regulatory_mapping && evidenceData.regulatory_mapping.evidence_statement) {
                                description = evidenceData.regulatory_mapping.evidence_statement;
                            } else if (evidenceData.encryption_algorithm) {
                                // Build description from encryption details
                                const parts = [];
                                if (evidenceData.encryption_algorithm) parts.push(`Algorithm: ${evidenceData.encryption_algorithm}`);
                                if (evidenceData.key_derivation) parts.push(`Key Derivation: ${evidenceData.key_derivation}`);
                                if (parts.length > 0) description = parts.join(', ');
                            }
                        }
                    } catch (e) {
                        console.warn('Failed to parse evidence_data for enhanced description:', e);
                        // Keep default description
                    }
                    
                    // Improve placeholder descriptions
                    if (!description || description === 'N/A' || description === 'NA') {
                        const et = (source.evidence_type || '').toLowerCase();
                        if (et.includes('audit')) {
                            description = 'System access and activity logs (audit trail)';
                        } else if (et.includes('encryption')) {
                            description = 'Automated data integrity checks and encryption validation logs';
                        } else if (et.includes('data integrity') || et.includes('file validation')) {
                            description = 'Automated integrity pipeline including: SHA-256 checksum verification, CSV schema/format validation, well/channel consistency checks, pathogen threshold mapping enforcement, and audit trail entry creation.';
                        } else {
                            description = 'Automated data integrity checks and validation logs';
                        }
                    }

                    // If this row is grouped, append count in description
                    if (source.__group_count && source.__group_count > 1) {
                        description += ` (${source.__group_count} checks)`;
                    }

                    evidenceHTML += `
                        <tr>
                            <td><span class="badge bg-primary">${source.evidence_type || 'Analysis Session'}</span></td>
                            <td style="max-width: 500px; word-wrap: break-word; white-space: normal;">${description}</td>
                            <td><span class="badge ${statusBadge}">${statusText}</span></td>
                            <td>${dateStr}</td>
                        </tr>`;
                });
                
                evidenceHTML += `
                                        </tbody>
                                    </table>
                                </div>
                                <div class="alert alert-success mt-3">
                                    <i class="fas fa-check-circle"></i>
                                    <strong>Evidence Source:</strong> Direct API integration - real-time evidence tracking
                                </div>
                            </div>
                        </div>`;
                }
                // Render sources card (if any) and continue to add logs/sessions so the count matches total shown
                if (evidenceHTML) {
                    evidenceContainer.innerHTML = evidenceHTML;
                }
            }
            
            // Render Documentation upload/list UI when policy allows
            try {
                const allowDocs = (window.EvidenceFilter?.getAllowedEvidenceTypes?.(reqCode) || []).includes('documentation');
                const container = document.getElementById('evidenceDetails');
                if (allowDocs && container) {
                    const docSectionId = `docUpload_${reqCode}`;
                    if (!document.getElementById(docSectionId)) {
                        const block = document.createElement('div');
                        block.id = docSectionId;
                        block.className = 'card mb-3 border-info';
                        block.innerHTML = `
                            <div class="card-header bg-info text-white d-flex justify-content-between align-items-center">
                                <h6 class="mb-0"><i class="fas fa-file-upload"></i> Documentation</h6>
                                <small>Attach SOPs, policies, or supporting documents</small>
                            </div>
                            <div class="card-body">
                                <form id="docForm_${reqCode}" class="row g-2 align-items-center" onsubmit="return false;">
                                    <div class="col-md-5">
                                        <input type="file" class="form-control form-control-sm" id="docFile_${reqCode}" accept=".pdf,.doc,.docx,.txt,.md,.rtf,.csv,.tsv,.xlsx,.xls,.png,.jpg,.jpeg">
                                    </div>
                                    <div class="col-md-5">
                                        <input type="text" class="form-control form-control-sm" id="docDesc_${reqCode}" placeholder="Short description (optional)">
                                    </div>
                                    <div class="col-md-2 text-end">
                                        <button class="btn btn-sm btn-primary" id="docBtn_${reqCode}">Upload</button>
                                    </div>
                                </form>
                                <div id="docMsg_${reqCode}" class="mt-2"></div>
                                <div class="mt-3">
                                    <h6 class="mb-2"><i class="fas fa-folder-open"></i> Uploaded Documents</h6>
                                    <div id="docList_${reqCode}"><small class="text-muted">None yet</small></div>
                                </div>
                            </div>`;
                        // Prepend near top for visibility
                        if (container.firstChild) container.insertBefore(block, container.firstChild);
                        else container.appendChild(block);

                        // Wire upload button
                        const btn = block.querySelector(`#docBtn_${reqCode}`);
                        btn?.addEventListener('click', async () => {
                            const fileEl = block.querySelector(`#docFile_${reqCode}`);
                            const descEl = block.querySelector(`#docDesc_${reqCode}`);
                            const msg = block.querySelector(`#docMsg_${reqCode}`);
                            if (!fileEl || !fileEl.files || !fileEl.files[0]) {
                                msg.innerHTML = '<div class="alert alert-warning py-1 my-1">Choose a file to upload.</div>';
                                return;
                            }
                            try {
                                const fd = new FormData();
                                fd.append('file', fileEl.files[0]);
                                fd.append('requirement_id', reqCode);
                                if (descEl && descEl.value) fd.append('description', descEl.value);
                                const resp = await fetch('/api/unified-compliance/evidence/documentation/upload', { method: 'POST', body: fd });
                                const data = await resp.json();
                                if (!resp.ok || data.success === false) throw new Error(data.error || 'Upload failed');
                                msg.innerHTML = '<div class="alert alert-success py-1 my-1">Uploaded.</div>';
                                // Refresh list
                                await window.loadDocumentationListFor(reqCode);
                                // Bump evidence count subtly
                                try { const el = document.getElementById('evidenceCountValue'); if (el) el.textContent = (parseInt(el.textContent||'0',10)+1); } catch {}
                                // Clear form
                                fileEl.value = '';
                                if (descEl) descEl.value = '';
                            } catch (e) {
                                msg.innerHTML = `<div class="alert alert-danger py-1 my-1">${e.message}</div>`;
                            }
                        });

                        // Helper to load list
                        window.loadDocumentationListFor = async function(reqId){
                            try {
                                const listEl = document.getElementById(`docList_${reqId}`);
                                if (!listEl) return;
                                const r = await fetch(`/api/unified-compliance/evidence/documentation/list?requirement_id=${encodeURIComponent(reqId)}`);
                                const data = await r.json();
                                if (!r.ok || data.success === false) throw new Error(data.error || 'Failed to load documents');
                                const docs = Array.isArray(data.documents) ? data.documents : [];
                                if (!docs.length) { listEl.innerHTML = '<small class="text-muted">None yet</small>'; return; }
                                listEl.innerHTML = `
                                    <div class="table-responsive">
                                        <table class="table table-sm table-striped align-middle mb-0">
                                            <thead><tr><th>Name</th><th>Type</th><th>Size</th><th>Uploaded</th><th></th></tr></thead>
                                            <tbody>
                                                ${docs.map(d => {
                                                    const size = (d.size_bytes && d.size_bytes > 0) ? (d.size_bytes >= 1024*1024 ? (d.size_bytes/1024/1024).toFixed(1)+' MB' : Math.ceil(d.size_bytes/1024)+' KB') : '-';
                                                    const when = d.created_at ? new Date(d.created_at).toLocaleString() : '-';
                                                    const desc = d.description ? `<div><small class=\"text-muted\">${d.description}</small></div>` : '';
                                                    return `
                                                        <tr>
                                                            <td style="max-width:380px; word-break:break-word;">
                                                                <div><strong>${d.filename || 'document'}</strong></div>
                                                                ${desc}
                                                            </td>
                                                            <td><small>${d.mime_type || '-'}</small></td>
                                                            <td><small>${size}</small></td>
                                                            <td><small>${when}</small></td>
                                                            <td class="text-end">
                                                                <a class="btn btn-sm btn-outline-primary me-1" href="/api/unified-compliance/evidence/documentation/serve/${d.evidence_id}" target="_blank">Open</a>
                                                                <button class="btn btn-sm btn-outline-danger" data-doc-delete="${d.evidence_id}">Delete</button>
                                                            </td>
                                                        </tr>`;
                                                }).join('')}
                                            </tbody>
                                        </table>
                                    </div>`;

                                // Wire delete buttons
                                listEl.querySelectorAll('button[data-doc-delete]')?.forEach(btn => {
                                    btn.addEventListener('click', async (ev) => {
                                        const id = ev.currentTarget.getAttribute('data-doc-delete');
                                        if (!id) return;
                                        if (!confirm('Delete this document from the server? This cannot be undone.')) return;
                                        try {
                                            const r = await fetch(`/api/unified-compliance/evidence/documentation/delete/${id}`, { method: 'DELETE' });
                                            const data = await r.json();
                                            if (!r.ok || data.success === false) {
                                                // Permission-aware messaging
                                                const msg = data?.error || 'Delete failed';
                                                alert(msg.includes('Insufficient') ? 'Not allowed: you need Compliance Officer, QC Technician, or Admin role.' : msg);
                                                return;
                                            }
                                            await window.loadDocumentationListFor(reqId);
                                        } catch (e) {
                                            alert(e.message || 'Delete failed');
                                        }
                                    });
                                });
                            } catch (e) {
                                const listEl = document.getElementById(`docList_${reqId}`);
                                if (listEl) listEl.innerHTML = `<div class="alert alert-danger py-1 my-1">${e.message}</div>`;
                            }
                        };
                        // Initial list
                        window.loadDocumentationListFor(reqCode);
                    }
                }
            } catch {}

            // Fallback to the original method if no evidence_sources
            console.log('Using fallback evidence method for', reqCode);
            
            // Determine allowed evidence types for this requirement
            const allowedTypes = (window.EvidenceFilter?.getAllowedEvidenceTypes?.(reqCode) || []);
            const hasEncryptionEvidence = allowedTypes.includes('encryption_evidence');
            const needsAuditLogs = allowedTypes.includes('audit_logs');
            const needsValidationTests = allowedTypes.includes('validation_tests');
            
            // Fetch evidence from multiple sources (use cached sessions to avoid extra calls)
            const evidencePromises = [
                Promise.resolve({ confirmed_sessions: window.cachedSessions?.confirmed || [] }),
                Promise.resolve({ pending_sessions: window.cachedSessions?.pending || [] })
            ];
            
            // Add encryption evidence if relevant
            if (hasEncryptionEvidence) {
                // Use the requirement code as-is; backend supports CFR_11_10_* directly
                const apiId = reqCode;
                evidencePromises.push(
                    fetch(`/api/unified-compliance/encryption-evidence/${apiId}`).then(r => r.ok ? r.json() : { success: false })
                );
            }
            // Add software validation tests (comprehensive system validation)
            if (needsValidationTests) {
                // Use a cached result if we have one during this page session
                const getValidationResult = () => {
                    try {
                        if (window.__validationCache && window.__validationCache.result) {
                            return Promise.resolve(window.__validationCache.result);
                        }
                    } catch {}
                    return fetch('/api/unified-compliance/validate-system', { method: 'POST' })
                        .then(r => r.ok ? r.json() : { success: false, error: r.status })
                        .then(data => {
                            try { window.__validationCache = { result: data, ts: Date.now() }; } catch {}
                            return data;
                        })
                        .catch(() => ({ success: false }));
                };
                evidencePromises.push(getValidationResult());
            }
            if (needsAuditLogs) {
                evidencePromises.push(
                    fetch('/api/auth/audit-log?limit=50').then(r => r.ok ? r.json() : { success: false })
                );
            }
            
            Promise.all(evidencePromises).then((results) => {
                try {
                    const [confirmedData, pendingData] = results;
                    // Compute offsets safely based on which optional calls were included
                    let idx = 2;
                    const encryptionData = hasEncryptionEvidence ? results[idx++] : null;
                    const validationData = needsValidationTests ? results[idx++] : null;
                    const auditLogData = needsAuditLogs ? results[idx++] : null;

                    console.log('Loading evidence files for', reqCode);

                    const evidenceContainer = document.getElementById('evidenceDetails');
                    if (!evidenceContainer) return;

                    // Combine and filter session files as evidence
                    const confirmedSessions = confirmedData.confirmed_sessions || [];
                    const pendingSessions = pendingData.pending_sessions || [];
                    let filtered = { confirmedSessions, pendingSessions, encryptionData };
                    try {
                        if (window.EvidenceFilter?.filterEvidenceForRequirement) {
                            filtered = window.EvidenceFilter.filterEvidenceForRequirement(reqCode, confirmedSessions, pendingSessions, encryptionData);
                        }
                    } catch (e) {
                        console.warn('EvidenceFilter failed, showing unfiltered sessions:', e);
                    }
                    const allSessions = [...(filtered.confirmedSessions || []), ...(filtered.pendingSessions || [])];
                    // Remove sessions already represented by evidence_sources to avoid duplicate sections
                    const deDupedSessions = Array.isArray(allSessions)
                        ? allSessions.filter(s => !(s && typeof s.id !== 'undefined' && coveredSessionIds.has(s.id)))
                        : [];

                    let evidenceHTML = '';

                // Add encryption evidence section if available
                if (hasEncryptionEvidence && encryptionData && encryptionData.success) {
                    console.log('Raw encryption evidence data:', encryptionData);
                    
                    // Handle enhanced evidence format safely
                    let evidence, testCount, passedTests, complianceStatus;
                    
                    try {
                        if (encryptionData.evidence_data && typeof encryptionData.evidence_data === 'string') {
                            evidence = JSON.parse(encryptionData.evidence_data);
                            console.log('Parsed enhanced evidence:', evidence);
                            
                            // Enhanced evidence format - use safe property access
                            if (evidence.technical_specifications || evidence.system_verification) {
                                const validationResults = evidence.validation_results || {};
                                testCount = validationResults.files_present || 4;
                                passedTests = validationResults.encryption_functional ? testCount : 0;
                                complianceStatus = (evidence.regulatory_mapping && evidence.regulatory_mapping.compliance_status) || 'IMPLEMENTED';
                            } else {
                                // Simple analysis evidence
                                testCount = 1;
                                passedTests = (evidence.success_rate > 0) ? 1 : 0;
                                complianceStatus = (evidence.good_curves > 0) ? 'IMPLEMENTED' : 'PENDING';
                            }
                        } else {
                            // Fallback for old format
                            evidence = encryptionData.evidence || encryptionData;
                            testCount = 1;
                            passedTests = 1;
                            complianceStatus = 'IMPLEMENTED';
                        }
                    } catch (e) {
                        console.warn('Evidence parsing failed, using fallback:', e);
                        evidence = { title: 'Encryption Evidence', description: 'System encryption verified' };
                        testCount = 1;
                        passedTests = 1;
                        complianceStatus = 'IMPLEMENTED';
                    }
                    
                    const statusBadge = complianceStatus === 'IMPLEMENTED' || complianceStatus === 'COMPLIANT' ? 'bg-success' : 'bg-warning';

                    // Resolve a sane timestamp; avoid epoch/Invalid Date when missing
                    let tsRaw = (evidence && evidence.timestamp) || (encryptionData && encryptionData.created_at);
                    let tsSafe = new Date();
                    try {
                        if (tsRaw) {
                            const dt = new Date(tsRaw);
                            if (!isNaN(dt.getTime()) && dt.getFullYear() > 1970) tsSafe = dt;
                        }
                    } catch {}

                    // Build encryption evidence section into a local buffer
                    const mountId = `encryptionEvidence_${reqCode}`;
                    let encSection = `
                        <div id="${mountId}" class="card mb-3 border-primary">
                            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                                <h6 class="mb-0"><i class="fas fa-shield-alt"></i> Encryption & Security Controls Evidence</h6>
                                ${(() => { try { const s = evidence?.regulatory_mapping?.evidence_strength; return s ? `<span class=\"badge bg-light text-dark\">Strength: ${s}</span>` : ''; } catch { return ''; } })()}
                            </div>
                            <div class="card-body">
                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <strong>Compliance Status:</strong> <span class="badge ${statusBadge}">${complianceStatus}</span>
                                    </div>
                                    <div class="col-md-6">
                                        <strong>Tests Passed:</strong> ${passedTests}/${testCount}
                                    </div>
                                </div>
                                
                                <h6>Implementation Details:</h6>
                                <div class="table-responsive">
                                    <table class="table table-sm">
                                        <thead>
                                            <tr>
                                                <th>Component</th>
                                                <th>Status</th>
                                                <th>Details</th>
                                            </tr>
                                        </thead>
                                        <tbody>`;
                    
                    // Handle different evidence formats for test display
                    if (evidence.implementation_tests) {
                        // Old format with implementation_tests
                        encSection += Object.entries(evidence.implementation_tests).map(([testName, testResult]) => {
                            const statusBadge = testResult.passed ? 'bg-success' : 'bg-danger';
                            const statusText = testResult.passed ? 'PASS' : 'FAIL';
                            return `
                                <tr>
                                    <td><small>${testName.replace(/_/g, ' ').toUpperCase()}</small></td>
                                    <td><span class="badge ${statusBadge}">${statusText}</span></td>
                                    <td><small>${testResult.details || 'Test executed successfully'}</small></td>
                                </tr>
                            `;
                        }).join('');
                    } else if (evidence.filename && evidence.good_curves !== undefined) {
                        // Simple analysis evidence format (current database format)
                        const analysisSuccess = evidence.good_curves > 0;
                        const statusBadge = analysisSuccess ? 'bg-success' : 'bg-warning';
                        const statusText = analysisSuccess ? 'OPERATIONAL' : 'PENDING';
                        const successPercent = evidence.total_wells > 0 ? ((evidence.good_curves / evidence.total_wells) * 100).toFixed(1) : '0';
                        
                        encSection += `
                            <tr>
                                <td><small>Analysis Execution</small></td>
                                <td><span class="badge ${statusBadge}">${statusText}</span></td>
                                <td><small>File: ${evidence.filename.split(' - ')[0]} (${evidence.fluorophore})</small></td>
                            </tr>
                            <tr>
                                <td><small>Curve Quality</small></td>
                                <td><span class="badge bg-info">${successPercent}%</span></td>
                                <td><small>${evidence.good_curves}/${evidence.total_wells} wells passed quality checks</small></td>
                            </tr>
                            <tr>
                                <td><small>System Performance</small></td>
                                <td><span class="badge bg-success">VALIDATED</span></td>
                                <td><small>Analysis completed at ${new Date(evidence.timestamp).toLocaleString()}</small></td>
                            </tr>
                        `;
                    } else if (evidence.compliance_evidence && Array.isArray(evidence.compliance_evidence)) {
                        // New enhanced format with compliance_evidence array
                        encSection += evidence.compliance_evidence.map((item, index) => `
                            <tr>
                                <td><small>Control ${index + 1}</small></td>
                                <td><span class="badge bg-success">IMPLEMENTED</span></td>
                                <td><small>${item}</small></td>
                            </tr>
                        `).join('');
                    } else {
                        // Fallback display
                        encSection += `
                            <tr>
                                <td><small>Encryption Implementation</small></td>
                                <td><span class="badge bg-success">OPERATIONAL</span></td>
                                <td><small>System encryption controls verified</small></td>
                            </tr>
                        `;
                    }
                    
                    // Collect descriptive controls from multiple sources
                    try {
                        const controlSet = new Set();
                        // Direct list on evidence
                        if (Array.isArray(evidence.encryption_controls)) {
                            evidence.encryption_controls.forEach(c => c && controlSet.add(String(c)));
                        }
                        // Compliance mapping style: object of org -> { encryption_controls: [...] }
                        const cmap = evidence.compliance_mapping || {};
                        if (cmap && typeof cmap === 'object') {
                            Object.values(cmap).forEach(entry => {
                                try {
                                    if (entry && Array.isArray(entry.encryption_controls)) {
                                        entry.encryption_controls.forEach(c => c && controlSet.add(String(c)));
                                    }
                                } catch {}
                            });
                        }
                        // Flatten to array
                        const controls = Array.from(controlSet);
                        if (controls.length > 0) {
                            encSection += `
                                <div class="alert alert-secondary mt-3">
                                    <strong>Encryption Controls Implemented:</strong>
                                    <ul class="mb-0 mt-2">
                                        ${controls.map(item => `<li>${item}</li>`).join('')}
                                    </ul>
                                </div>
                            `;
                        }
                    } catch (e) { /* non-blocking */ }

                    encSection += `
                                        </tbody>
                                    </table>
                                </div>
                                
                                ${evidence.technical_specifications ? `
                                    <div class="alert alert-info mt-3">
                                        <strong>Technical Specifications:</strong>
                                        <ul class="mb-0 mt-2">
                                            ${Object.entries(evidence.technical_specifications).map(([key, value]) => 
                                                `<li><strong>${key.replace(/_/g, ' ').toUpperCase()}:</strong> ${value}</li>`
                                            ).join('')}
                                        </ul>
                                    </div>
                                ` : ''}
                                
                                ${evidence.compliance_evidence && Array.isArray(evidence.compliance_evidence) ? `
                                    <div class="alert alert-success mt-3">
                                        <strong>Compliance Evidence:</strong>
                                        <ul class="mb-0 mt-2">
                                            ${evidence.compliance_evidence.map(item => `<li>${item}</li>`).join('')}
                                        </ul>
                                    </div>
                                ` : ''}

                                ${(() => {
                                    try {
                                        const sys = evidence.system_verification || {};
                                        const si = sys.system_info || {};
                                        const rv = sys.runtime_verification || {};
                                        const files = sys.implementation_files || {};
                                        const cfg = sys.configuration_evidence || {};
                                        const cfgEntries = Object.entries(cfg);
                                        const cfgConfigured = cfgEntries.filter(([,v]) => v && v.configured).length;
                                        const cfgTotal = cfgEntries.length;
                                        const hasAny = (Object.keys(si).length + Object.keys(rv).length + Object.keys(files).length + cfgEntries.length) > 0;
                                        if (!hasAny) return '';
                                        const sysInfoHtml = Object.keys(si).length ? `
                                            <div class=\"mb-3\">
                                                <h6><i class=\"fas fa-microchip\"></i> System Info</h6>
                                                <div class=\"table-responsive\">
                                                    <table class=\"table table-sm\">
                                                        <tbody>
                                                            ${Object.entries(si).map(([k,v]) => `<tr><td style=\"width:220px\"><small><strong>${k.replace(/_/g,' ').toUpperCase()}</strong></small></td><td><small>${String(v)}</small></td></tr>`).join('')}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>` : '';
                                        const filesHtml = Object.keys(files).length ? `
                                            <div class=\"mb-3\">
                                                <h6><i class=\"fas fa-file-code\"></i> Implementation Files</h6>
                                                <div class=\"table-responsive\">
                                                    <table class=\"table table-sm table-striped\">
                                                        <thead><tr><th>File</th><th>Status</th><th>Size</th><th>Hash</th><th>Contains</th><th>Modified</th></tr></thead>
                                                        <tbody>
                                                            ${Object.entries(files).map(([name,meta]) => {
                                                                const ok = meta && meta.exists;
                                                                const size = (meta && meta.size_bytes!=null) ? `${meta.size_bytes} B` : '-';
                                                                const hash = (meta && meta.hash_sha256) ? `${meta.hash_sha256.slice(0,12)}…` : '-';
                                                                const contains = [];
                                                                if (meta && meta.contains_fernet) contains.push('Fernet');
                                                                if (meta && (meta.contains_aes || meta.contains_AES)) contains.push('AES');
                                                                if (meta && meta.contains_encryption) contains.push('encrypt');
                                                                const modified = (meta && meta.last_modified) ? new Date(meta.last_modified).toLocaleString() : '-';
                                                                const badge = ok ? '<span class=\"badge bg-success\">Present</span>' : '<span class=\"badge bg-secondary\">Missing</span>';
                                                                return `<tr>
                                                                    <td><small>${name}</small></td>
                                                                    <td>${badge}</td>
                                                                    <td><small>${size}</small></td>
                                                                    <td><small>${hash}</small></td>
                                                                    <td><small>${contains.join(', ') || '-'}</small></td>
                                                                    <td><small>${modified}</small></td>
                                                                </tr>`;
                                                            }).join('')}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>` : '';
                                        const rvHtml = Object.keys(rv).length ? `
                                            <div class=\"mb-3\">
                                                <h6><i class=\"fas fa-vial\"></i> Runtime Verification</h6>
                                                <div>
                                                    <span class=\"badge ${rv.encryption_test_passed ? 'bg-success' : 'bg-danger'}\">${rv.encryption_test_passed ? 'ENCRYPTION TEST PASS' : 'ENCRYPTION TEST FAIL'}</span>
                                                    <div class=\"mt-2\"><small>
                                                        ${rv.algorithm_confirmed ? `<strong>Algorithm:</strong> ${rv.algorithm_confirmed} &nbsp; ` : ''}
                                                        ${rv.key_length_bytes != null ? `<strong>Key Length:</strong> ${rv.key_length_bytes} B &nbsp; ` : ''}
                                                        ${rv.encrypted_data_length_bytes != null ? `<strong>Ciphertext Length:</strong> ${rv.encrypted_data_length_bytes} B &nbsp; ` : ''}
                                                        ${rv.test_timestamp ? `<strong>Tested:</strong> ${new Date(rv.test_timestamp).toLocaleString()}` : ''}
                                                    </small></div>
                                                </div>
                                            </div>` : '';
                                        const cfgHtml = cfgEntries.length ? `
                                            <div class=\"mb-2\">
                                                <h6><i class=\"fas fa-lock\"></i> Configuration Evidence <small class=\"text-muted\">(${cfgConfigured}/${cfgTotal} configured)</small></h6>
                                                <div class=\"table-responsive\">
                                                    <table class=\"table table-sm\">
                                                        <thead><tr><th>Variable</th><th>Status</th><th>Length</th><th>Hash Preview</th></tr></thead>
                                                        <tbody>
                                                            ${cfgEntries.map(([k,v]) => {
                                                                const ok = v && v.configured;
                                                                const len = ok && v.length != null ? v.length : '-';
                                                                const hp = ok && v.hash_preview ? v.hash_preview : '-';
                                                                const badge = ok ? '<span class=\"badge bg-success\">Configured</span>' : '<span class=\"badge bg-secondary\">Missing</span>';
                                                                return `<tr><td><small>${k}</small></td><td>${badge}</td><td><small>${len}</small></td><td><small>${hp}</small></td></tr>`;
                                                            }).join('')}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>` : '';
                                        return `
                                            <div class=\"mt-3 p-3 border rounded\">
                                                <div class=\"mb-2\"><strong><i class=\"fas fa-clipboard-check\"></i> Inspector-Level System Verification</strong></div>
                                                ${sysInfoHtml}
                                                ${filesHtml}
                                                ${rvHtml}
                                                ${cfgHtml}
                                            </div>
                                        `;
                                    } catch { return ''; }
                                })()}
                                
                                ${evidence.recommendations && evidence.recommendations.length > 0 ? `
                                    <div class="alert alert-info mt-3">
                                        <strong>Recommendations:</strong>
                                        <ul class="mb-0 mt-2">
                                            ${evidence.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                                        </ul>
                                    </div>
                                ` : ''}
                                
                                <small class="text-muted">
                                    <i class="fas fa-clock"></i> Evidence generated: ${tsSafe.toLocaleString()}
                                </small>
                            </div>
                        </div>
                    `;
                    // Append the encryption section to the overall evidence buffer
                    evidenceHTML += encSection;
                }
                    // Note: Do not reference blockHtml outside the encryption block scope; it's block-scoped.
                    // We already inserted/replaced the encryption section directly in the DOM above.
                
                // Add Validation Tests section when configured
                if (needsValidationTests) {
                    try {
                        // Aggregate from multiple sources: system validation payload, encryption evidence, and evidence_sources rows
                        const aggregateValidation = (primary, encryption, sources) => {
                            const acc = { overall: 'UNKNOWN', passed: 0, warns: 0, fails: 0, total: 0 };
                            const apply = (v) => {
                                if (!v) return;
                                try {
                                    // Common shapes
                                    const summary = v.summary || v.validation_summary || {};
                                    // Arrays of checks
                                    acc.passed += (Array.isArray(v.passed_checks) ? v.passed_checks.length : (summary.passed || 0));
                                    acc.warns  += (Array.isArray(v.warnings) ? v.warnings.length : (summary.warnings || summary.major_warnings || 0));
                                    acc.fails  += (Array.isArray(v.critical_failures) ? v.critical_failures.length : (summary.critical_failures || 0));
                                    // Map-form validation_results: { test: {status: PASS|WARNING|FAIL} }
                                    const vrMap = v.validation_results && !Array.isArray(v.validation_results) && typeof v.validation_results === 'object' ? v.validation_results : null;
                                    if (vrMap) {
                                        Object.values(vrMap).forEach(x => {
                                            const s = (x && (x.status || x.result || x.overall_status || '')).toString().toUpperCase();
                                            if (s.includes('FAIL')) acc.fails += 1;
                                            else if (s.includes('WARN')) acc.warns += 1;
                                            else if (s.includes('PASS') || s === 'OK' || s === 'SUCCESS') acc.passed += 1;
                                        });
                                    }
                                    // Overall
                                    const o = (v.overall_status || summary.overall_status || v.status || '').toString().toUpperCase();
                                    if (o) acc.overall = o;
                                } catch {}
                            };

                            // 1) Primary system validation
                            if (primary && primary.success !== false) apply(primary);

                            // 2) Encryption evidence embedded validation
                            if (encryption && encryption.success !== false) {
                                let e = encryption.evidence_data || encryption.evidence || encryption;
                                try { if (typeof e === 'string') e = JSON.parse(e); } catch {}
                                if (e && e.validation_results) apply(e);
                            }

                            // 3) Embedded validation inside evidence_sources rows
                            (Array.isArray(sources) ? sources : []).forEach(src => {
                                let data = src && src.evidence_data;
                                try { if (typeof data === 'string') data = JSON.parse(data); } catch {}
                                if (data && (data.validation_results || data.summary || data.passed_checks)) apply(data);
                            });

                            acc.total = (acc.passed + acc.warns + acc.fails);
                            if (acc.overall === 'UNKNOWN') {
                                // Infer overall from counts if not explicitly provided
                                acc.overall = acc.fails > 0 ? 'CRITICAL_FAILURE' : (acc.warns > 0 ? 'WARNING' : (acc.passed > 0 ? 'PASS' : 'UNKNOWN'));
                            }
                            return acc;
                        };

                        const vt = aggregateValidation(validationData, encryptionData, renderSources);
                        const badge = (vt.overall === 'PASS') ? 'bg-success' : (vt.overall === 'WARNING' ? 'bg-warning' : (vt.overall === 'UNKNOWN' ? 'bg-secondary' : 'bg-danger'));

                        evidenceHTML += `
                            <div class="card mb-3 border-primary">
                                <div class="card-header bg-primary text-white">
                                    <h6><i class="fas fa-vial"></i> Validation Tests</h6>
                                </div>
                                <div class="card-body">
                                    <div class="row text-center">
                                        <div class="col-md-3">
                                            <div><span class="badge ${badge}">${vt.overall}</span></div>
                                            <small class="text-muted">Overall Status</small>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="text-success fw-bold">${vt.passed}</div>
                                            <small class="text-muted">Pass</small>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="text-warning fw-bold">${vt.warns}</div>
                                            <small class="text-muted">Warnings</small>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="text-danger fw-bold">${vt.fails}</div>
                                            <small class="text-muted">Failures</small>
                                        </div>
                                    </div>
                                    ${vt.total ? `<div class="mt-3"><small class="text-muted">Total checks: ${vt.total}</small></div>` : ''}
                                    ${(() => {
                                        try {
                                            const details = [];
                                            const pushMap = (m, srcLabel) => {
                                                if (!m || typeof m !== 'object') return;
                                                Object.entries(m).forEach(([name, obj]) => {
                                                    const s = (obj && (obj.status || obj.result || obj.overall_status || '')).toString().toUpperCase() || 'UNKNOWN';
                                                    const msg = (obj && (obj.message || obj.description || obj.detail || '')) || '';
                                                    details.push({ name, status: s, message: msg, src: srcLabel || '' });
                                                });
                                            };
                                            if (validationData && validationData.validation_results && typeof validationData.validation_results === 'object') {
                                                pushMap(validationData.validation_results, 'System');
                                            }
                                            try {
                                                let e = encryptionData && (encryptionData.evidence_data || encryptionData.evidence || encryptionData);
                                                if (typeof e === 'string') { try { e = JSON.parse(e); } catch {} }
                                                if (e && e.validation_results) pushMap(e.validation_results, 'Encryption');
                                            } catch {}
                                            (Array.isArray(renderSources) ? renderSources : []).forEach(src => {
                                                let data = src && src.evidence_data;
                                                if (typeof data === 'string') { try { data = JSON.parse(data); } catch {} }
                                                if (data && data.validation_results) pushMap(data.validation_results, src.evidence_type || 'Evidence');
                                            });
                                            if (!details.length) return '';
                                            const listId = `valDetails-${Date.now()}`;
                                            const rows = details.map(d => {
                                                const color = d.status.includes('FAIL') ? 'text-danger' : (d.status.includes('WARN') ? 'text-warning' : (d.status.includes('PASS') ? 'text-success' : 'text-muted'));
                                                return `<tr><td>${d.src}</td><td>${d.name}</td><td class=\"${color}\">${d.status}</td><td>${d.message || ''}</td></tr>`;
                                            }).join('');
                                            return `
                                                <div class=\"mt-3\">
                                                    <a href=\"#\" onclick=\"(function(){ const el=document.getElementById('${listId}'); if(el){ el.style.display=(el.style.display==='none'?'block':'none'); } })(); return false;\">Show test details</a>
                                                    <div id=\"${listId}\" style=\"display:none\" class=\"mt-2\">
                                                        <div class=\"table-responsive\">
                                                            <table class=\"table table-sm\">
                                                                <thead><tr><th>Source</th><th>Check</th><th>Status</th><th>Message</th></tr></thead>
                                                                <tbody>${rows}</tbody>
                                                            </table>
                                                        </div>
                                                    </div>
                                                </div>
                                            `;
                                        } catch { return ''; }
                                    })()}
                                </div>
                            </div>
                        `;
                    } catch (e) {
                        console.warn('Validation tests render failed:', e);
                    }
                }
                
                // Add session files evidence if this requirement uses run files
                const allowRunFiles = (() => {
                    try { return (window.EvidenceFilter?.getAllowedEvidenceTypes?.(reqCode) || []).some(t => t === 'run_files' || t === 'validation_tests'); } catch { return true; }
                })();

                if (allowRunFiles && deDupedSessions.length > 0) {
                    evidenceHTML += `
                        <div class="card mb-3">
                            <div class="card-header">
                                <h6><i class="fas fa-file-alt"></i> Analysis Session Records (${deDupedSessions.length} files)</h6>
                            </div>
                            <div class="card-body">
                                <p class="text-muted mb-3">qPCR analysis files providing evidence for this compliance requirement:</p>
                                
                                <div class="table-responsive">
                                    <table class="table table-striped table-sm">
                                        <thead>
                                            <tr>
                                                <th>Session ID</th>
                                                <th>Filename</th>
                                                <th>Upload Date</th>
                                                <th>Pathogen</th>
                                                <th>Wells</th>
                                                <th>Status</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${deDupedSessions.map(session => {
                                                // Derive a user-friendly pathogen label for sessions
                                                let pathogenInfo = (session.pathogen_breakdown || '').split(':')[0].trim();
                                                let pathogenBadgeClass = 'bg-info';
                                                let pathogenTitle = '';
                                                
                                                // If missing/unknown, try to infer from filename using pathogen library helpers
                                                if (!pathogenInfo || pathogenInfo.toLowerCase() === 'unknown' || pathogenInfo === '-') {
                                                    const filename = session.filename || '';
                                                    // Extract test code from base pattern (e.g., AcMgen_... -> Mgen)
                                                    let inferredTest = '';
                                                    try {
                                                        if (window.extractTestCode) {
                                                            // Handle multi-fluorophore prefix and trim artifacts
                                                            const base = filename.replace(/ -\s+Quantification Amplification Results_[A-Za-z0-9\s]+\.csv$/, '')
                                                                                .replace(/\s+-\s*$/, '');
                                                            inferredTest = window.extractTestCode(base);
                                                        }
                                                    } catch (e) { /* noop */ }
                                                    // Map to friendly pathogen name when possible
                                                    if (inferredTest) {
                                                        const friendly = window.getPathogenName ? window.getPathogenName(inferredTest) : inferredTest;
                                                        if (friendly && friendly.toLowerCase() !== 'unknown pathogen') {
                                                            pathogenInfo = friendly;
                                                            pathogenBadgeClass = 'bg-info';
                                                            pathogenTitle = 'Inferred from filename';
                                                        }
                                                    }
                                                    // Final fallback
                                                    if (!pathogenInfo || pathogenInfo.toLowerCase() === 'unknown' || pathogenInfo === '-' ) {
                                                        pathogenInfo = 'N/A';
                                                        pathogenBadgeClass = 'bg-secondary';
                                                        pathogenTitle = 'No pathogen metadata for this session (not applicable or missing)';
                                                    }
                                                }
                                                const uploadDate = session.upload_timestamp ? new Date(session.upload_timestamp).toLocaleString() : 'N/A';
                                                const wells = session.total_wells || 0;
                                                const status = session.confirmation_status || 'Unknown';
                                                const statusBadge = status === 'confirmed' ? 'bg-success' : status === 'pending' ? 'bg-warning' : 'bg-secondary';
                                                const statusHint = status === 'pending' ? '<br><small class="text-muted">Awaiting expert confirmation in History</small>' : '';
                                                
                                                return `
                                                    <tr>
                                                        <td><span class="badge bg-primary">${session.id}</span></td>
                                                        <td>
                                                            <small title="${session.filename}">
                                                                ${session.filename ? session.filename.substring(0, 50) + (session.filename.length > 50 ? '...' : '') : 'Unknown'}
                                                            </small>
                                                        </td>
                                                        <td><small>${uploadDate}</small></td>
                                                        <td><span class="badge ${pathogenBadgeClass}" ${pathogenTitle ? `title="${pathogenTitle}"` : ''}>${pathogenInfo}</span></td>
                                                        <td><small>${wells}</small></td>
                                                        <td><span class="badge ${statusBadge}">${status}</span>${statusHint}</td>
                                                    </tr>
                                                `;
                                            }).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                
                                <div class="alert alert-info mt-3">
                                    <i class="fas fa-info-circle"></i>
                                    <strong>Evidence Type:</strong> qPCR Analysis Session Files<br>
                                    <strong>Total Files:</strong> ${deDupedSessions.length}<br>
                                    <strong>Compliance Value:</strong> Each file represents execution of controlled analysis procedures supporting this requirement.
                                </div>
                            </div>
                        </div>
                    `;
                } else if (allowRunFiles && !hasEncryptionEvidence) {
                    // Only show this warning if no prior evidence was rendered
                    if (!(evidenceContainer && evidenceContainer.innerHTML.trim())) {
                        evidenceHTML += `
                            <div class="alert alert-warning">
                                <i class="fas fa-info-circle"></i>
                                No session files found as evidence for this requirement.
                            </div>
                        `;
                    }
                }

                // Add audit logs section if allowed and available
                if (needsAuditLogs && auditLogData && (Array.isArray(auditLogData.log_entries) ? auditLogData.log_entries.length : 0)) {
                    const entries = Array.isArray(auditLogData.log_entries) ? auditLogData.log_entries : [];
                    // Group entries by date for a true activity view
                    const byDate = entries.reduce((acc, e) => {
                        const d = e.timestamp ? new Date(e.timestamp) : null;
                        const key = d ? d.toISOString().slice(0,10) : 'Unknown Date';
                        (acc[key] = acc[key] || []).push(e);
                        return acc;
                    }, {});
                    const sortedDates = Object.keys(byDate).sort((a,b) => b.localeCompare(a));

                    evidenceHTML += `
                        <div class="card mb-3 border-warning">
                            <div class="card-header bg-warning text-dark">
                                <h6><i class="fas fa-clipboard-list"></i> Audit Logs</h6>
                                <small class="text-muted">Showing ${entries.length} events from authentication/access audit trail</small>
                            </div>
                            <div class="card-body">
                                ${sortedDates.map((dateKey, idx) => {
                                    const dayEntries = byDate[dateKey];
                                    const collapseId = `audit_${dateKey.replace(/[^A-Za-z0-9_]/g,'_')}_${idx}`;
                                    return `
                                        <div class="mb-2 border rounded">
                                            <div class="p-2 bg-light d-flex justify-content-between align-items-center" role="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="${idx===0?'true':'false'}">
                                                <div><strong>${dateKey}</strong> <span class="badge bg-secondary">${dayEntries.length}</span></div>
                                                <i class="fas fa-chevron-${idx===0?'down':'right'}"></i>
                                            </div>
                                            <div id="${collapseId}" class="collapse ${idx===0?'show':''}">
                                                <div class="table-responsive">
                                                    <table class="table table-sm table-striped mb-0">
                                                        <thead>
                                                            <tr>
                                                                <th>Time</th>
                                                                <th>User</th>
                                                                <th>Action</th>
                                                                <th>Method</th>
                                                                <th>Path / Endpoint</th>
                                                                <th>Status</th>
                                                                <th>IP</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            ${dayEntries.map(e => {
                                                                const t = e.timestamp ? new Date(e.timestamp) : null;
                                                                const time = t ? t.toLocaleTimeString() : '-';
                                                                const method = e.method || (e.details && (e.details.method || e.details.http_method)) || '-';
                                                                const path = e.path || e.endpoint || (e.details && (e.details.path || e.details.endpoint || e.details.url)) || '-';
                                                                const status = e.status_code || (e.details && (e.details.status || e.details.status_code)) || '-';
                                                                return `
                                                                    <tr>
                                                                        <td><small>${time}</small></td>
                                                                        <td><small>${e.user || 'system'}</small></td>
                                                                        <td><small>${e.action || 'event'}</small></td>
                                                                        <td><small>${method}</small></td>
                                                                        <td style="max-width:420px"><small>${path}</small></td>
                                                                        <td><small>${status}</small></td>
                                                                        <td><small>${e.ip_address || '-'}</small></td>
                                                                    </tr>`;
                                                            }).join('')}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>
                                        </div>`;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }
                
                    // Show combined evidence or a clear message if none; always clear the loading spinner
                    if (!evidenceHTML) {
                        evidenceHTML = `
                            <div class="alert alert-warning">
                                <i class="fas fa-info-circle"></i>
                                No evidence found for this requirement.
                            </div>
                        `;
                    }

                    // Replace modal content with the full assembled buffer so multiple evidence types show together
                    if (evidenceContainer) {
                        evidenceContainer.innerHTML = evidenceHTML;
                    }

                    // Recalculate and update Evidence Count to match everything displayed
                    try {
                        const req = (window.requirementsData || []).find(r => r.id === reqCode) || {};
                        const sources = Array.isArray(req.evidence_sources) ? req.evidence_sources : [];
                        // Estimate validation test records (respect current allowed types)
                        let validationCount = 0;
                        try {
                            const allowedNow = window.EvidenceFilter?.getAllowedEvidenceTypes?.(reqCode) || [];
                            const allowVT = allowedNow.includes('validation_tests');
                            if (allowVT && validationData) {
                                if (validationData.validation_results && typeof validationData.validation_results === 'object') {
                                    validationCount = Object.keys(validationData.validation_results).length;
                                } else {
                                    const pc = (validationData.passed_checks || []).length;
                                    const cf = (validationData.critical_failures || []).length;
                                    const w = (validationData.warnings || []).length;
                                    validationCount = pc + cf + w;
                                    // Do not force minimal evidence if zero; reflect actual absence
                                }
                            }
                        } catch {}
                        const count = window.EvidenceFilter?.getRelevantEvidenceCount?.(reqCode, confirmedSessions, pendingSessions, encryptionData, sources, auditLogData)
                            || (deDupedSessions.length + (encryptionData ? (window.EvidenceFilter?.countEncryptionRecords?.(encryptionData) || 0) : 0) + sources.length + validationCount);
                        const el = document.getElementById('evidenceCountValue');
                        if (el) el.textContent = count;
                    } catch {}

                    console.log(`✅ Loaded evidence for requirement ${reqCode} (${deDupedSessions.length} sessions${hasEncryptionEvidence ? ', encryption controls' : ''})`);
                } catch (error) {
                    console.error('Evidence render error:', error);
                    const evidenceContainer = document.getElementById('evidenceDetails');
                    if (evidenceContainer) {
                        const existing = evidenceContainer.innerHTML.trim();
                        const alertHtml = `
                            <div class="alert alert-danger">
                                <i class="fas fa-exclamation-triangle"></i>
                                Error rendering evidence: ${error.message}
                            </div>
                        `;
                        evidenceContainer.innerHTML = existing ? (existing + alertHtml) : alertHtml;
                    }
                }
            }).catch(error => {
                console.error('Error loading evidence:', error);
                const evidenceContainer = document.getElementById('evidenceDetails');
                if (evidenceContainer) {
                    evidenceContainer.innerHTML = `
                        <div class="alert alert-danger">
                            <i class="fas fa-exclamation-triangle"></i>
                            Error loading evidence: ${error.message}
                        </div>
                    `;
                }
            });
        }

        async function viewEvidence(reqCode) {
            // Redirect to simple evidence viewer
            const req = window.requirementsData.find(r => r.id === reqCode);
            const evidenceCount = req ? req.evidence_count || 0 : 0;
            showSimpleEvidence(reqCode, evidenceCount);
        }

        function showEvidenceReport(reqCode, evidence) {
            const reportSection = document.getElementById('evidenceReportSection');
            const reportTitle = document.getElementById('evidenceReportTitle');
            const reportContent = document.getElementById('evidenceReportContent');
            
            // Set title
            reportTitle.textContent = `Evidence Report: ${reqCode}`;
            
            // Generate detailed report content
            const html = generateEvidenceReportHTML(reqCode, evidence);
            reportContent.innerHTML = html;
            
            // Show the report section
            reportSection.style.display = 'block';
            
            // Scroll to the report
            reportSection.scrollIntoView({ behavior: 'smooth' });
        }

        function generateEvidenceReportHTML(reqCode, evidence) {
            if (evidence.error) {
                return `<div class="alert alert-danger">Error: ${evidence.error}</div>`;
            }
            
            const requirementInfo = evidence.requirement_info || {};
            const complianceSummary = evidence.compliance_summary || {};
            const evidenceRecords = evidence.detailed_evidence_records || [];
            
            let html = `
                <div class="evidence-report">
                    <!-- Requirement Header -->
                    <div class="row mb-4">
                        <div class="col-md-8">
                            <h4>${reqCode}</h4>
                            <p class="text-muted">${requirementInfo.title || 'Unknown Title'}</p>
                            <p><small>${requirementInfo.description || 'No description available'}</small></p>
                        </div>
                        <div class="col-md-4">
                            <div class="card bg-light">
                                <div class="card-body text-center">
                                    <h5 class="text-primary">${complianceSummary.total_evidence_records || 0}</h5>
                                    <small class="text-muted">Evidence Records</small>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Compliance Summary -->
                    <div class="card mb-4">
                        <div class="card-header">
                            <h6><i class="fas fa-chart-bar"></i> Compliance Summary</h6>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-3">
                                    <strong>Total Records:</strong><br>
                                    <span class="badge badge-primary">${complianceSummary.total_evidence_records || 0}</span>
                                </div>
                                <div class="col-md-3">
                                    <strong>Evidence Coverage:</strong><br>
                                    <span class="badge badge-success">${complianceSummary.evidence_coverage || 0}</span>
                                </div>
                                <div class="col-md-3">
                                    <strong>Latest Activity:</strong><br>
                                    <small>${formatTimestamp(complianceSummary.latest_activity)}</small>
                                </div>
                                <div class="col-md-3">
                                    <strong>Tracking Events:</strong><br>
                                    <small>${(complianceSummary.tracking_events || []).length} event types</small>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Evidence Records -->
                    <div class="card">
                        <div class="card-header">
                            <h6><i class="fas fa-list"></i> Detailed Evidence Records (${evidenceRecords.length})</h6>
                        </div>
                        <div class="card-body">
            `;
            
            if (evidenceRecords.length === 0) {
                html += `<div class="alert alert-warning">No detailed evidence records found for this requirement.</div>`;
            } else {
                evidenceRecords.slice(0, 10).forEach((record, index) => {
                    html += `
                        <div class="evidence-record mb-4 p-3 border rounded">
                            <div class="d-flex justify-content-between align-items-start mb-2">
                                <h6 class="mb-1">
                                    <i class="fas fa-file-alt text-primary"></i> 
                                    Record #${index + 1}: ${record.evidence_classification || 'Evidence Record'}
                                </h6>
                                <small class="text-muted">${formatTimestamp(record.record_timestamp)}</small>
                            </div>
                            
                            <div class="mb-2">
                                <strong>Inspector Summary:</strong><br>
                                <span class="text-info">${record.regulatory_summary || 'No summary available'}</span>
                            </div>
                            
                            ${record.technical_verification ? `
                                <div class="mb-2">
                                    <strong>Technical Verification:</strong>
                                    <div class="ml-3">
                                        ${Object.entries(record.technical_verification).slice(0, 5).map(([key, value]) => 
                                            `<small><strong>${key}:</strong> ${value}</small><br>`
                                        ).join('')}
                                    </div>
                                </div>
                            ` : ''}
                            
                            ${record.compliance_documentation ? `
                                <div class="mb-2">
                                    <strong>Regulatory Citation:</strong><br>
                                    <span class="badge badge-info">${record.compliance_documentation.regulation_cite || 'N/A'}</span>
                                </div>
                                <div>
                                    <strong>Evidence Statement:</strong><br>
                                    <small class="text-muted">${record.compliance_documentation.evidence_statement || 'No statement'}</small>
                                </div>
                            ` : ''}
                            
                            <div class="mt-2">
                                <small class="text-muted">
                                    <strong>Audit Trail ID:</strong> ${record.audit_trail_id || 'N/A'}
                                </small>
                            </div>
                        </div>
                    `;
                });
                
                if (evidenceRecords.length > 10) {
                    html += `<div class="alert alert-info">Showing first 10 of ${evidenceRecords.length} evidence records.</div>`;
                }
            }
            
            html += `
                        </div>
                    </div>
                </div>
            `;
            
            return html;
        }

        function closeEvidenceReport() {
            const reportSection = document.getElementById('evidenceReportSection');
            reportSection.style.display = 'none';
        }

        function formatTimestamp(timestamp) {
            if (!timestamp) return 'No timestamp';
            try {
                const date = new Date(timestamp);
                return date.toLocaleString();
            } catch (e) {
                return timestamp;
            }
        }

        function showEvidenceModal(reqCode, evidence) {
            // Legacy function - now redirects to proper report
            viewEvidence(reqCode);
        }

        // Export functions
        async function exportComplianceReport(type) {
            try {
                const response = await fetch(`/api/compliance/export/${type}`);
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `compliance_report_${type}_${new Date().toISOString().split('T')[0]}.${type === 'detailed' ? 'xlsx' : 'pdf'}`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    showAlert('Report exported successfully', 'success');
                } else {
                    throw new Error('Export failed');
                }
            } catch (error) {
                console.error('Error exporting report:', error);
                showAlert('Error exporting report', 'danger');
            }
        }

        async function exportOrganizationReport() {
            const org = document.getElementById('orgFilter').value;
            try {
                const response = await fetch(`/api/compliance/export/organization/${org}`);
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `compliance_${org}_${new Date().toISOString().split('T')[0]}.pdf`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    showAlert('Organization report exported successfully', 'success');
                } else {
                    throw new Error('Export failed');
                }
            } catch (error) {
                console.error('Error exporting organization report:', error);
                showAlert('Error exporting organization report', 'danger');
            }
        }

        async function exportRoadmapReport() {
            try {
                const response = await fetch('/api/compliance/export/roadmap');
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `implementation_roadmap_${new Date().toISOString().split('T')[0]}.pdf`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    showAlert('Roadmap exported successfully', 'success');
                } else {
                    throw new Error('Export failed');
                }
            } catch (error) {
                console.error('Error exporting roadmap:', error);
                showAlert('Error exporting roadmap', 'danger');
            }
        }

        function showAlert(message, type) {
            // Allow swapped argument order: showAlert('success', 'Saved!')
            const validTypes = ['primary','secondary','success','danger','warning','info','light','dark'];
            if (validTypes.includes(message) && (!type || !validTypes.includes(type))) {
                const swapped = message; message = type || 'Action completed'; type = swapped;
            }

            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
            alertDiv.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
            alertDiv.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            document.body.appendChild(alertDiv);
            
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.parentNode.removeChild(alertDiv);
                }
            }, 5000);
        }

        // ML Validation Functions - Enhanced with version control and pathogen models
        async function loadMLValidationData() {
            try {
                console.log('🔍 Loading session validation data for unified dashboard...');

                // Load pending sessions from the new session endpoint
                const pendingResponse = await fetch('/api/sessions/pending');
                let pendingCount = 0;
                if (pendingResponse.ok) {
                    const pendingData = await pendingResponse.json();
                    console.log('📊 Pending sessions data received:', pendingData);
                    
                    if (pendingData.success) {
                        pendingCount = pendingData.count || 0;
                        updatePendingRuns(pendingData);
                    } else {
                        console.error('❌ Pending sessions API error:', pendingData.message);
                        showErrorInMLSection('mlPendingRunsList', pendingData.message || 'Unknown error');
                    }
                } else {
                    console.error('❌ Pending sessions API request failed:', pendingResponse.status);
                    showErrorInMLSection('mlPendingRunsList', `API request failed: ${pendingResponse.status}`);
                }

                // Load confirmed sessions from the new session endpoint
                const confirmedResponse = await fetch('/api/sessions/confirmed');
                let confirmedCount = 0;
                if (confirmedResponse.ok) {
                    const confirmedData = await confirmedResponse.json();
                    console.log('📊 Confirmed sessions data received:', confirmedData);
                    
                    if (confirmedData.success) {
                        confirmedCount = confirmedData.count || 0;
                        updateConfirmedRuns(confirmedData);
                        // Update models and average accuracy directly from confirmed sessions
                        try { updateAvgAndModelsFromSessions(confirmedData); } catch (_) {}
                    } else {
                        console.error('❌ Confirmed sessions API error:', confirmedData.message);
                        showErrorInMLSection('mlConfirmedRunsList', confirmedData.message || 'Unknown error');
                    }
                } else {
                    console.error('❌ Confirmed sessions API request failed:', confirmedResponse.status);
                    showErrorInMLSection('mlConfirmedRunsList', `API request failed: ${confirmedResponse.status}`);
                }

                // Update session statistics
                updateSessionStatistics(pendingCount, confirmedCount);

                // Load ML statistics (keep this for ML metrics)
                try {
                    const statsResponse = await fetch('/api/ml-validation/dashboard-data');
                    if (statsResponse.ok) {
                        const statsData = await statsResponse.json();
                        if (statsData.success) {
                            updateMLStatistics(statsData.statistics);
                            // Render pathogen models using confirmed sessions (independent of stats)
                            updatePathogenModels(statsData);
                        } else {
                            // Still render pathogen models from confirmed sessions if stats not successful
                            updatePathogenModels(null);
                        }
                    } else {
                        // Stats endpoint not available; proceed to render pathogen models from confirmed sessions
                        updatePathogenModels(null);
                    }
                } catch (e) {
                    console.log('ML statistics not available:', e.message);
                    // Proceed with rendering pathogen models using confirmed sessions so UI doesn’t stall
                    try { updatePathogenModels(null); } catch (_) {}
                }

            } catch (error) {
                console.error('🚨 Error loading session validation data:', error);
                showErrorInMLSection('mlPendingRunsList', `Connection error: ${error.message}`);
            }
        }

        // Compute and render ML Average Accuracy and Active Pathogen Models from confirmed sessions
        function updateAvgAndModelsFromSessions(confirmedData) {
            const sessions = confirmedData?.confirmed_sessions || [];
            // Average Accuracy
            let total = 0;
            let n = 0;
            sessions.forEach(s => {
                const acc = parseFloat(s.ml_accuracy_percentage ?? s.expert_accuracy ?? 100);
                if (!isNaN(acc)) { total += acc; n++; }
            });
            const avg = n > 0 ? (total / n) : 0;
            const mlAvgAccuracyEl = document.getElementById('mlAvgAccuracy');
            if (mlAvgAccuracyEl) mlAvgAccuracyEl.textContent = `${avg.toFixed(1)}%`;
            // Active Pathogen Models (unique pathogens across confirmed sessions)
            const unique = new Set();
            sessions.forEach(s => {
                const p = (s.pathogen_breakdown || '').split(':')[0].trim();
                if (p && p.toLowerCase() !== 'unknown' && p !== '-') unique.add(p);
            });
            const mlTotalModelsEl = document.getElementById('mlTotalModels');
            if (mlTotalModelsEl) mlTotalModelsEl.textContent = unique.size;
        }

        function updateSessionStatistics(pendingCount, confirmedCount) {
            // Update the main statistics with session counts
            const mlPendingCountEl = document.getElementById('mlPendingCount');
            if (mlPendingCountEl) {
                mlPendingCountEl.textContent = pendingCount;
            }
            
            const mlConfirmedCountEl = document.getElementById('mlConfirmedCount');
            if (mlConfirmedCountEl) {
                mlConfirmedCountEl.textContent = confirmedCount;
            }
            
            // Update tab count
            const pendingTabCount = document.getElementById('mlPendingTabCount');
            if (pendingTabCount) {
                pendingTabCount.textContent = pendingCount;
            }
        }

        function showErrorInMLSection(containerId, errorMessage) {
            const container = document.getElementById(containerId);
            if (container) {
                container.innerHTML = `
                    <div class="text-center text-danger py-4">
                        <i class="fas fa-exclamation-triangle fa-3x mb-3"></i>
                        <h5>Error Loading Data</h5>
                        <p>${errorMessage}</p>
                        <button class="btn btn-outline-primary btn-sm" onclick="loadMLValidationData()">
                            <i class="fas fa-sync"></i> Retry
                        </button>
                    </div>
                `;
            }
        }

        function updateMLStatistics(response) {
            console.log('📊 Updating ML statistics in unified dashboard:', response);
            
            // Get real-time session counts from the actual session APIs
            Promise.all([
                fetch('/api/sessions/pending').then(r => r.json()),
                fetch('/api/sessions/confirmed').then(r => r.json())
            ]).then(([pendingData, confirmedData]) => {
                const pendingCount = pendingData.pending_sessions?.length || 0;
                const confirmedCount = confirmedData.confirmed_sessions?.length || 0;
                
                // Update stat cards with real data
                const mlPendingCountEl = document.getElementById('mlPendingCount');
                if (mlPendingCountEl) {
                    mlPendingCountEl.textContent = pendingCount;
                }
                
                const mlConfirmedCountEl = document.getElementById('mlConfirmedCount');
                if (mlConfirmedCountEl) {
                    mlConfirmedCountEl.textContent = confirmedCount;
                }
                
                // Calculate real average accuracy from confirmed sessions
                let totalAccuracy = 0;
                let validAccuracyCount = 0;
                if (confirmedData.confirmed_sessions) {
                    confirmedData.confirmed_sessions.forEach(session => {
                        const accuracy = parseFloat(session.ml_accuracy_percentage || session.expert_accuracy || 100.0);
                        if (accuracy > 0) {
                            totalAccuracy += accuracy;
                            validAccuracyCount++;
                        }
                    });
                }
                
                const avgAccuracy = validAccuracyCount > 0 ? totalAccuracy / validAccuracyCount : 0;
                const mlAvgAccuracyEl = document.getElementById('mlAvgAccuracy');
                if (mlAvgAccuracyEl) {
                    mlAvgAccuracyEl.textContent = `${avgAccuracy.toFixed(1)}%`;
                }
                
                // For pathogen models, we'll count unique pathogens from confirmed sessions
                const uniquePathogens = new Set();
                if (confirmedData.confirmed_sessions) {
                    confirmedData.confirmed_sessions.forEach(session => {
                        const pathogenBreakdown = session.pathogen_breakdown || '';
                        const pathogenName = pathogenBreakdown.split(':')[0].trim();
                        if (pathogenName && pathogenName !== 'Unknown') {
                            uniquePathogens.add(pathogenName);
                        }
                    });
                }
                
                const mlTotalModelsEl = document.getElementById('mlTotalModels');
                if (mlTotalModelsEl) {
                    mlTotalModelsEl.textContent = uniquePathogens.size;
                }
                
                // Update tab count
                const pendingTabCount = document.getElementById('mlPendingTabCount');
                if (pendingTabCount) {
                    pendingTabCount.textContent = pendingCount;
                }
                
                console.log(`✅ Updated stats: ${pendingCount} pending, ${confirmedCount} confirmed, ${uniquePathogens.size} pathogen models, ${avgAccuracy.toFixed(1)}% avg accuracy`);
            }).catch(error => {
                console.error('❌ Error fetching real-time session data:', error);
                
                // Fallback to original logic
                const stats = response?.statistics || response;
                const mlPendingCountEl = document.getElementById('mlPendingCount');
                if (mlPendingCountEl) {
                    mlPendingCountEl.textContent = stats?.pending_confirmation || stats?.pending_count || stats?.pending_runs || '-';
                }
                
                const mlConfirmedCountEl = document.getElementById('mlConfirmedCount');
                if (mlConfirmedCountEl) {
                    mlConfirmedCountEl.textContent = stats?.confirmed || stats?.confirmed_count || stats?.confirmed_runs || '-';
                }
                
                const mlTotalModelsEl = document.getElementById('mlTotalModels');
                if (mlTotalModelsEl) {
                    mlTotalModelsEl.textContent = stats?.total_models || stats?.active_models || '0';
                }
                
                const mlAvgAccuracyEl = document.getElementById('mlAvgAccuracy');
                if (mlAvgAccuracyEl) {
                    const accuracy = stats?.average_accuracy || stats?.avg_accuracy || 0;
                    mlAvgAccuracyEl.textContent = `${(accuracy * 100).toFixed(1)}%`;
                }
            });
        }

        function updatePendingRuns(response) {
            const container = document.getElementById('mlPendingRunsList');
            if (!container) {
                console.error('❌ mlPendingRunsList container not found');
                return;
            }
            
            const sessions = response.pending_sessions || response; // Handle both nested and flat arrays
            
            if (!sessions || !Array.isArray(sessions) || sessions.length === 0) {
                console.log('ℹ️ No pending sessions found for unified dashboard');
                container.innerHTML = `
                    <div class="text-center text-muted py-4">
                        <i class="fas fa-check-circle fa-3x mb-3"></i>
                        <h5>No Pending Sessions</h5>
                        <p>All analysis sessions have been reviewed and confirmed.</p>
                        <small class="text-muted">Found ${sessions ? sessions.length : 0} pending sessions</small>
                    </div>
                `;
                return;
            }

            console.log(`✅ Displaying ${sessions.length} pending sessions in unified dashboard`);
            container.innerHTML = sessions.map(session => `
                <div class="card mb-3 border-warning">
                    <div class="card-body">
                        <div class="row align-items-center">
                            <div class="col-md-8">
                                <h6 class="card-title mb-2">
                                    <i class="fas fa-flask text-primary"></i> Session ${session.id}
                                </h6>
                                <div class="run-details">
                                    <p class="mb-1"><strong>File:</strong> ${session.filename || 'Unknown File'}</p>
                                    <p class="mb-1"><strong>Pathogen Info:</strong> 
                                        ${(() => {
                                            const raw = (session.pathogen_breakdown || '').split(':')[0].trim();
                                            if (!raw || raw.toLowerCase() === 'unknown' || raw === '-') {
                                                return '<span class="badge bg-secondary" title="No pathogen metadata (not applicable or missing)">N/A</span>';
                                            }
                                            return `<span class=\"badge bg-info\">${raw}</span>`;
                                        })()}
                                    </p>
                                    <p class="mb-1"><strong>Created:</strong> ${session.upload_timestamp ? new Date(session.upload_timestamp).toLocaleString() : 'N/A'}</p>
                                    <small class="text-muted"><strong>Status:</strong> ${session.confirmation_status}</small>
                                </div>
                            </div>
                            <div class="col-md-4 text-end">
                                <div class="confirmation-question mb-3">
                                    <small class="text-muted">Pending analysis session</small>
                                </div>
                                <div class="btn-group-vertical d-grid gap-2">
                                    <small class="text-info mb-2">
                                        <i class="fas fa-info-circle"></i> 
                                        Confirm this session from the main analysis page
                                    </small>
                                    <button class="btn btn-outline-danger btn-sm" onclick="deleteSession('${session.id}')">
                                        <i class="fas fa-trash"></i> Delete
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function updateConfirmedRuns(response) {
            const container = document.getElementById('mlConfirmedRunsList');
            
            // Extract the actual sessions array from the API response
            const sessions = response.confirmed_sessions || [];
            
            if (!Array.isArray(sessions) || sessions.length === 0) {
                container.innerHTML = `
                    <div class="text-center text-muted py-4">
                        <i class="fas fa-history fa-3x mb-3"></i>
                        <h5>No Confirmed Sessions</h5>
                        <p>Confirmed analysis sessions will appear here.</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = `
                <div class="table-responsive">
                    <table class="table table-hover">
                        <thead class="table-light">
                            <tr>
                                <th><i class="fas fa-id-badge"></i> Session ID</th>
                                <th><i class="fas fa-file"></i> File</th>
                                <th><i class="fas fa-virus"></i> Pathogen</th>
                                <th><i class="fas fa-chart-line"></i> Accuracy</th>
                                <th><i class="fas fa-user"></i> Confirmed By</th>
                                <th><i class="fas fa-calendar"></i> Confirmed</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${sessions.map(session => {
                                // Use ML accuracy instead of pathogen success rate
                                const rawAccuracy = session.ml_accuracy_percentage || session.expert_accuracy || 100.0;
                                const expertAccuracy = parseFloat(rawAccuracy) || 100.0; // Ensure it's a number
                                const hasExpertDecisions = (session.expert_decisions_count || 0) > 0;
                                
                                // Clean pathogen name (remove percentage if present)
                                const pathogenName = (session.pathogen_breakdown || 'N/A').split(':')[0].trim();
                                
                                return `
                                <tr>
                                    <td><strong>${session.id}</strong></td>
                                    <td>${session.filename}</td>
                                    <td><span class="badge bg-info">${pathogenName}</span></td>
                                    <td>
                                        <span class="badge ${expertAccuracy >= 90 ? 'bg-success' : expertAccuracy >= 70 ? 'bg-warning' : 'bg-danger'}">
                                            ${expertAccuracy.toFixed(1)}%
                                        </span>
                                        <br>
                                        <small class="text-primary">
                                            ${hasExpertDecisions ? 'System accuracy with expert decisions' : 'System accuracy (no expert decisions required)'}
                                        </small>
                                        <br>
                                        <small class="text-muted">
                                            ${session.correct_predictions || session.total_wells}/${session.total_predictions || session.total_wells} samples correctly analyzed
                                        </small>
                                    </td>
                                    <td><small>${session.confirmed_by || 'N/A'}</small></td>
                                    <td><small>${session.confirmed_at ? new Date(session.confirmed_at).toLocaleString() : 'N/A'}</small></td>
                                </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function updatePathogenModels(response) {
            const container = document.getElementById('mlPathogenModels');
            
            // Get real pathogen data from confirmed sessions
            fetch('/api/sessions/confirmed')
                .then(r => r.json())
                .then(confirmedData => {
                    // Build pathogen models from confirmed sessions
                    const pathogenStats = {};
                    
                    if (confirmedData.confirmed_sessions) {
                        confirmedData.confirmed_sessions.forEach(session => {
                            const pathogenBreakdown = session.pathogen_breakdown || '';
                            const pathogenName = pathogenBreakdown.split(':')[0].trim();

                            if (pathogenName && pathogenName !== 'Unknown') {
                                if (!pathogenStats[pathogenName]) {
                                    pathogenStats[pathogenName] = {
                                        sessionCount: 0,
                                        totalAccuracy: 0,   // percentage 0–100 sum across sessions
                                        totalWells: 0,
                                        versions: new Set()
                                    };
                                }

                                pathogenStats[pathogenName].sessionCount++;
                                // Use ML accuracy percentage computed backend with expert grouping; fallback to expert_accuracy, else 100%
                                const sessionAccuracy = parseFloat(
                                    (session.ml_accuracy_percentage != null ? session.ml_accuracy_percentage : (session.expert_accuracy != null ? session.expert_accuracy : 100.0))
                                ) || 0;
                                pathogenStats[pathogenName].totalAccuracy += sessionAccuracy;
                                pathogenStats[pathogenName].totalWells += parseInt(session.total_wells || 0);
                                pathogenStats[pathogenName].versions.add('1.0'); // Version placeholder
                            }
                        });
                    }
                    
                    const pathogenArray = Object.entries(pathogenStats);
                    
                    if (pathogenArray.length === 0) {
                        container.innerHTML = `
                            <div class="text-center text-muted py-4">
                                <i class="fas fa-virus fa-3x mb-3"></i>
                                <h5>No Pathogen Models</h5>
                                <p>Pathogen model data will appear here after analyzing samples.</p>
                                <small>Models are created automatically when processing pathogen-specific samples.</small>
                            </div>
                        `;
                        return;
                    }
                    
                    container.innerHTML = pathogenArray.map(([pathogen, stats]) => {
                        const avgAccuracy = stats.sessionCount > 0 ? (stats.totalAccuracy / stats.sessionCount) : 0;
                        const currentVersion = Array.from(stats.versions)[0] || '1.0';
                        
                        return `
                            <div class="card mb-3">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <h6 class="mb-0">
                                        <i class="fas fa-virus text-info"></i> ${pathogen}
                                    </h6>
                                    <span class="badge bg-primary">v${currentVersion}</span>
                                </div>
                                <div class="card-body">
                                    <div class="row">
                                        <div class="col-md-3">
                                            <div class="metric">
                                                <div class="metric-value text-success">${stats.sessionCount}</div>
                                                <div class="metric-label">Sessions Analyzed</div>
                                            </div>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="metric">
                                                <div class="metric-value text-info">${avgAccuracy.toFixed(1)}%</div>
                                                <div class="metric-label">Average Accuracy</div>
                                            </div>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="metric">
                                                <div class="metric-value text-warning">${stats.totalWells}</div>
                                                <div class="metric-label">Total Wells</div>
                                            </div>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="metric">
                                                <div class="metric-value text-primary">Active</div>
                                                <div class="metric-label">Status</div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Training Control Section -->
                                    <div class="mt-3 pt-3 border-top">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <div>
                                                <small class="text-muted">
                                                    <i class="fas fa-brain text-success"></i> ML Training: <span class="text-success">Enabled</span>
                                                </small>
                                            </div>
                                            <div class="btn-group btn-group-sm" role="group">
                                                <button class="btn btn-outline-success pathogen-training-btn" 
                                                        data-pathogen="${pathogen}" 
                                                        data-action="enable"
                                                        onclick="togglePathogenTraining('${pathogen}', true)"
                                                        title="Enable ML training for ${pathogen}"
                                                        style="display: none;">
                                                    <i class="fas fa-play"></i> Enable
                                                </button>
                                                <button class="btn btn-outline-warning pathogen-training-btn" 
                                                        data-pathogen="${pathogen}" 
                                                        data-action="disable"
                                                        onclick="togglePathogenTraining('${pathogen}', false)"
                                                        title="Disable ML training for ${pathogen}">
                                                    <i class="fas fa-pause"></i> Disable
                                                </button>
                                            </div>
                                        </div>
                                        <div class="mt-2" style="display: none;">
                                            <small id="training-status-${pathogen}" class="text-muted">
                                                <!-- Status checked via API call -->
                                            </small>
                                        </div>
                                    </div>
                                    
                                    <div class="mt-3">
                                        <small class="text-muted">
                                            <i class="fas fa-clock"></i> Last updated: ${new Date().toLocaleString()}
                                        </small>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    console.log(`✅ Updated pathogen models: ${pathogenArray.length} pathogens found`);
                })
                .catch(error => {
                    console.error('❌ Error fetching pathogen model data:', error);
                    container.innerHTML = `
                        <div class="text-center text-muted py-4">
                            <i class="fas fa-exclamation-triangle fa-3x mb-3"></i>
                            <h5>Error Loading Models</h5>
                            <p>Unable to load pathogen model data.</p>
                            <small>Error: ${error.message}</small>
                        </div>
                    `;
                });
                
            // Initialize pathogen-specific training status 
            updatePathogenTrainingStatus();
        }

        // ML Training Control Functions
        async function pauseTraining() {
            try {
                const userRole = getCurrentUserRole();
                const scope = determineTrainingScope(userRole);
                
                const response = await fetch('/api/ml-training/pause', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ scope: scope })
                });

                if (response.ok) {
                    const result = await response.json();
                    showAlert('success', `Training paused ${scope === 'global' ? 'system-wide' : 'for your session'}: ${result.message}`);
                    updateTrainingStatus();
                } else {
                    const error = await response.json();
                    showAlert('danger', `Failed to pause training: ${error.error}`);
                }
            } catch (error) {
                console.error('Error pausing training:', error);
                showAlert('danger', 'Error pausing training. Please try again.');
            }
        }

        async function resumeTraining() {
            try {
                const userRole = getCurrentUserRole();
                const scope = determineTrainingScope(userRole);
                
                const response = await fetch('/api/ml-training/resume', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ scope: scope })
                });

                if (response.ok) {
                    const result = await response.json();
                    showAlert('success', `Training resumed ${scope === 'global' ? 'system-wide' : 'for your session'}: ${result.message}`);
                    updateTrainingStatus();
                } else {
                    const error = await response.json();
                    showAlert('danger', `Failed to resume training: ${error.error}`);
                }
            } catch (error) {
                console.error('Error resuming training:', error);
                showAlert('danger', 'Error resuming training. Please try again.');
            }
        }

        async function updateTrainingStatus() {
            try {
                const response = await fetch('/api/ml-training/status');
                if (response.ok) {
                    const status = await response.json();
                    const userRole = getCurrentUserRole();
                    
                    // Show/hide buttons based on training status and user role
                    updateTrainingControlUI(status, userRole);
                    
                    // Update status message
                    const statusElement = document.getElementById('trainingStatusMessage');
                    if (statusElement) {
                        if (status.is_paused) {
                            statusElement.innerHTML = `<small><i class="fas fa-pause text-warning"></i> Training paused (${status.scope}): ${status.reason || 'No reason provided'}</small>`;
                            statusElement.style.display = 'block';
                        } else {
                            statusElement.innerHTML = `<small><i class="fas fa-play text-success"></i> Training active</small>`;
                            statusElement.style.display = 'block';
                        }
                    }
                } else {
                    console.error('Failed to fetch training status');
                }
            } catch (error) {
                console.error('Error fetching training status:', error);
            }
        }

        function updateTrainingControlUI(status, userRole) {
            const pauseBtn = document.getElementById('pauseTrainingBtn');
            const resumeBtn = document.getElementById('resumeTrainingBtn');
            
            if (!pauseBtn || !resumeBtn) return;
            
            // Check if user has training control permissions
            const hasTrainingControl = ['research_user', 'qc_technician', 'compliance_officer', 'administrator'].includes(userRole);
            
            if (!hasTrainingControl) {
                pauseBtn.style.display = 'none';
                resumeBtn.style.display = 'none';
                return;
            }
            
            // Show appropriate button based on current status
            if (status.is_paused) {
                pauseBtn.style.display = 'none';
                resumeBtn.style.display = 'inline-block';
                
                // Update button text based on scope capability
                const scope = determineTrainingScope(userRole);
                if (scope === 'global') {
                    resumeBtn.innerHTML = '<i class="fas fa-play"></i> ▶️ Resume Training (System-wide)';
                } else {
                    resumeBtn.innerHTML = '<i class="fas fa-play"></i> ▶️ Resume Training (Session)';
                }
            } else {
                pauseBtn.style.display = 'inline-block';
                resumeBtn.style.display = 'none';
                
                // Update button text based on scope capability
                const scope = determineTrainingScope(userRole);
                if (scope === 'global') {
                    pauseBtn.innerHTML = '<i class="fas fa-pause"></i> ⏸️ Pause Training (System-wide)';
                } else {
                    pauseBtn.innerHTML = '<i class="fas fa-pause"></i> ⏸️ Pause Training (Session)';
                }
            }
        }

        function getCurrentUserRole() {
            // This would need to be implemented based on your authentication system
            // For now, returning a default role - this should be replaced with actual role detection
            return 'research_user'; // or get from session/JWT/cookie
        }

        function determineTrainingScope(userRole) {
            // QC and Admin can pause globally, Research users can only pause their session
            if (['qc_technician', 'compliance_officer', 'administrator'].includes(userRole)) {
                return 'global';
            } else {
                return 'session';
            }
        }

        // Update pathogen-specific training status
        async function updatePathogenTrainingStatus() {
            try {
                // Since training is enabled by default, we don't need to check individual status
                // Just ensure all pathogen training controls show "Enabled"
                const pathogenCards = document.querySelectorAll('[id^="training-status-"]');
                pathogenCards.forEach(statusElement => {
                    // Status is hidden now since training is enabled by default
                    statusElement.style.display = 'none';
                });
                
                console.log('✅ Pathogen training status updated - all enabled by default');
            } catch (error) {
                console.error('❌ Error updating pathogen training status:', error);
            }
        }

        // Pathogen-specific training control functions
        async function togglePathogenTraining(pathogenCode, enabled) {
            try {
                console.log(`Toggling training for ${pathogenCode}: ${enabled ? 'enable' : 'disable'}`);
                
                // Get the pathogen card to update buttons
                const pathogenCard = document.querySelector(`[data-pathogen="${pathogenCode}"]`)?.closest('.card');
                if (!pathogenCard) {
                    console.error(`Pathogen card not found for ${pathogenCode}`);
                    return;
                }
                
                const enableBtn = pathogenCard.querySelector('[data-action="enable"]');
                const disableBtn = pathogenCard.querySelector('[data-action="disable"]');
                const statusElement = pathogenCard.querySelector('.text-muted');
                
                // Update status to show processing
                if (statusElement) {
                    statusElement.innerHTML = `<i class="fas fa-spinner fa-spin text-primary"></i> ML Training: ${enabled ? 'Enabling' : 'Disabling'}...`;
                }
                
                // For now, simulate API call to ml-config endpoint
                // This should call the same endpoint that ml-config.html uses
                const fluorophores = ['FAM', 'HEX', 'Texas Red', 'Cy5'];
                let successCount = 0;
                
                for (const fluorophore of fluorophores) {
                    try {
                        // Simulate the API call that would update ml_pathogen_config table
                        const response = await fetch(`/api/ml-config/pathogen/${encodeURIComponent(pathogenCode)}/${encodeURIComponent(fluorophore)}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                enabled: enabled,
                                notes: `Training ${enabled ? 'enabled' : 'disabled'} via unified compliance dashboard`
                            })
                        });
                        
                        if (response.ok) {
                            successCount++;
                        }
                    } catch (error) {
                        console.error(`Error updating ${pathogenCode}/${fluorophore}:`, error);
                    }
                }
                
                // Update UI based on results
                if (successCount > 0) {
                    if (enabled) {
                        // Training enabled - show "Disable" button, hide "Enable" button
                        if (enableBtn) enableBtn.style.display = 'none';
                        if (disableBtn) disableBtn.style.display = 'inline-block';
                        if (statusElement) {
                            statusElement.innerHTML = `<i class="fas fa-brain text-success"></i> ML Training: <span class="text-success">Active</span>`;
                        }
                        showAlert('success', `Training enabled for ${pathogenCode} (${successCount}/${fluorophores.length} channels)`);
                    } else {
                        // Training disabled - show "Enable" button, hide "Disable" button
                        if (enableBtn) enableBtn.style.display = 'inline-block';
                        if (disableBtn) disableBtn.style.display = 'none';
                        if (statusElement) {
                            statusElement.innerHTML = `<i class="fas fa-brain text-warning"></i> ML Training: <span class="text-warning">Disabled</span>`;
                        }
                        showAlert('warning', `Training disabled for ${pathogenCode} (${successCount}/${fluorophores.length} channels)`);
                    }
                } else {
                    // Failed to update
                    if (statusElement) {
                        statusElement.innerHTML = `<i class="fas fa-exclamation-triangle text-danger"></i> ML Training: <span class="text-danger">Update Failed</span>`;
                    }
                    showAlert('danger', `Failed to ${enabled ? 'enable' : 'disable'} training for ${pathogenCode}`);
                }
                
            } catch (error) {
                console.error('Error toggling pathogen training:', error);
                showAlert('danger', `Error ${enabled ? 'enabling' : 'disabling'} training for ${pathogenCode}`);
            }
        }

        async function confirmRun(runLogId, runId, confirmed) {
            try {
                const response = await fetch('/api/ml-runs/confirm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        run_log_id: runLogId,
                        confirmed_by: 'Dashboard User', // TODO: Get actual user from session
                        is_confirmed: confirmed,
                        rejection_reason: confirmed ? null : 'Rejected via dashboard'
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    const action = confirmed ? 'confirmed' : 'rejected';
                    showAlert('success', `Run ${runId} ${action} successfully!`);
                    loadMLValidationData(); // Refresh all data
                } else {
                    showAlert('danger', `Error: ${result.message || result.error}`);
                }
            } catch (error) {
                console.error('Error confirming run:', error);
                showAlert('danger', 'Error processing run confirmation. Please try again.');
            }
        }

        // Delete a pending ML run
        async function deleteRun(runId) {
            if (!confirm('Are you sure you want to delete this pending run? This action cannot be undone.')) {
                return;
            }

            try {
                const response = await fetch('/api/ml-runs/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        run_id: runId
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    showAlert('success', `Run ${runId} deleted successfully!`);
                    loadMLValidationData(); // Refresh all data
                } else {
                    showAlert('danger', `Error: ${result.message || result.error}`);
                }
            } catch (error) {
                console.error('Error deleting run:', error);
                showAlert('danger', 'Error deleting run. Please try again.');
            }
        }

        // Delete a pending analysis session or confirmation
        async function deleteSession(sessionId) {
            if (!confirm('Are you sure you want to delete this pending session? This action cannot be undone.')) {
                return;
            }

            try {
                // For session separation: try both confirmation_id and session_id
                // The backend will determine which structure to use
                const response = await fetch('/api/sessions/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        confirmation_id: sessionId,  // Try as confirmation_id first
                        session_id: sessionId        // Fallback to session_id for legacy
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    showAlert('success', `Session ${sessionId} deleted successfully!`);
                    loadMLValidationData(); // Refresh all data
                } else {
                    showAlert('danger', `Error: ${result.message || result.error}`);
                }
            } catch (error) {
                console.error('Error deleting session:', error);
                showAlert('danger', 'Error deleting session. Please try again.');
            }
        }

        // Load ML validation data when the ML tab is activated
        document.addEventListener('DOMContentLoaded', function() {
            const mlTab = document.getElementById('ml-validation-tab');
            if (mlTab) {
                mlTab.addEventListener('shown.bs.tab', function (e) {
                    loadMLValidationData();
                });
            }
            
            // Handle URL fragments to navigate to specific tabs
            function handleURLFragment() {
                const hash = window.location.hash;
                if (hash === '#ml-confirmed') {
                    // Activate the ML validation main tab first
                    const mlMainTab = document.getElementById('ml-validation-tab');
                    if (mlMainTab) {
                        const mlMainTabInstance = new bootstrap.Tab(mlMainTab);
                        mlMainTabInstance.show();
                        
                        // Then activate the confirmed runs sub-tab
                        setTimeout(() => {
                            const confirmedTab = document.getElementById('ml-confirmed-tab');
                            if (confirmedTab) {
                                const confirmedTabInstance = new bootstrap.Tab(confirmedTab);
                                confirmedTabInstance.show();
                                
                                // Load ML validation data if not already loaded
                                loadMLValidationData();
                            }
                        }, 100);
                    }
                }
            }
            
            // Handle fragment on page load
            handleURLFragment();
            
            // Handle fragment on hash change (if user navigates with back/forward)
            window.addEventListener('hashchange', handleURLFragment);
        });
    </script>
</body>
</html>
